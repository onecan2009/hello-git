From f584c73ba1283c062f2a8e756fb84e8cae377b3b Mon Sep 17 00:00:00 2001
From: huang zhibao <hzb@rock-chips.com>
Date: Thu, 25 Aug 2016 15:24:13 +0800
Subject: [PATCH 04/11] rk3288w: clk: support hdmi clk setting

support hdmi hdcp 2.2,
add aclk_hdcp and clk_hdcp setting.
---
 arch/arm/boot/dts/rk3288-clocks.dtsi |  120 +++++++++++++++++++++++++++++++++-
 drivers/clk/rockchip/clk.c           |   54 ++++++++++++++-
 2 files changed, 169 insertions(+), 5 deletions(-)

diff --git a/arch/arm/boot/dts/rk3288-clocks.dtsi b/arch/arm/boot/dts/rk3288-clocks.dtsi
index 4c24b82..c2b4852 100755
--- a/arch/arm/boot/dts/rk3288-clocks.dtsi
+++ b/arch/arm/boot/dts/rk3288-clocks.dtsi
@@ -18,7 +18,7 @@
 		compatible = "rockchip,rk-clocks";
 		#address-cells = <1>;
 		#size-cells = <1>;
-		ranges = <0x0 0xFF760000 0x01b0>;
+		ranges;
 
 		fixed_rate_cons {
 			compatible = "rockchip,rk-fixed-rate-cons";
@@ -325,8 +325,8 @@
 			compatible = "rockchip,rk-clock-regs";
 			#address-cells = <1>;
 			#size-cells = <1>;
-			reg = <0x0000 0x3ff>;
-			ranges;
+			ranges = <0x0 0xff760000 0x1000>;
+			reg = <0xff760000 0x1000>;
 
 			/* PLL control regs */
 			pll_cons {
@@ -2777,5 +2777,119 @@
 
 			};
 		};
+		special_regs {
+			compatible = "rockchip,rk-clock-special-regs";
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x0 0xff770000 0x1000>;
+			reg = <0xff770000 0x1000>;
+
+			hdmi_dclk0: hdmi_dclk0_mux {
+				compatible = "rockchip,rk3188-mux-con";
+				reg = <0x03a8 0x10>;
+				rockchip,bits = <2 1>;
+				clocks = <&dclk_lcdc0>, <&dummy>;
+				clock-output-names = "hdmi_dclk0";
+				#clock-cells = <0>;
+				#clock-init-cells = <1>;
+			};
+
+			hdmi_dclk1: hdmi_dclk1_mux {
+				compatible = "rockchip,rk3188-mux-con";
+				reg = <0x03a8 0x10>;
+				rockchip,bits = <3 1>;
+				clocks = <&dclk_lcdc1>, <&dummy>;
+				clock-output-names = "hdmi_dclk1";
+				#clock-cells = <0>;
+				#clock-init-cells = <1>;
+			};
+
+			hdmi_dclk: hdmi_dclk_mux {
+				compatible = "rockchip,rk3188-mux-con";
+				reg = <0x025c 0x10>;
+				rockchip,bits = <4 1>;
+				clocks = <&hdmi_dclk0>, <&hdmi_dclk1>;
+				clock-output-names = "hdmi_dclk";
+				#clock-cells = <0>;
+				#clock-init-cells = <1>;
+			};
+
+			aclk_hdcp: aclk_hdcp_mux {
+				compatible = "rockchip,rk3188-mux-con";
+				reg = <0x03a8 0x10>;
+				rockchip,bits = <6 2>;
+				clocks = <&aclk_vio1>, <&clk_isp>, <&hdmi_dclk>, <&aclk_vio0>;
+				clock-output-names = "aclk_hdcp";
+				#clock-cells = <0>;
+				#clock-init-cells = <1>;
+			};
+
+			aclk_hdcp_div: aclk_hdcp_div {
+				compatible = "rockchip,rk3188-div-con";
+				reg = <0x03a8 0x10>;
+				rockchip,bits = <8 2>;
+				clocks = <&aclk_hdcp>;
+				clock-output-names = "aclk_hdcp";
+				rockchip,div-type = <CLK_DIVIDER_PLUS_ONE>;
+				#clock-cells = <0>;
+				rockchip,clkops-idx =
+					<CLKOPS_RATE_MUX_DIV>;
+			};
+
+			clk_hdcp: clk_hdcp_mux {
+				compatible = "rockchip,rk3188-mux-con";
+				reg = <0x03a8 0x10>;
+				rockchip,bits = <10 2>;
+				clocks = <&aclk_vio1>, <&clk_isp>, <&hdmi_dclk>, <&aclk_vio0>;
+				clock-output-names = "clk_hdcp";
+				#clock-cells = <0>;
+				#clock-init-cells = <1>;
+			};
+
+			clk_hdcp_div: clk_hdcp_div {
+				compatible = "rockchip,rk3188-div-con";
+				reg = <0x03a8 0x10>;
+				rockchip,bits = <12 2>;
+				clocks = <&clk_hdcp>;
+				clock-output-names = "clk_hdcp";
+				rockchip,div-type = <CLK_DIVIDER_PLUS_ONE>;
+				#clock-cells = <0>;
+				rockchip,clkops-idx =
+					<CLKOPS_RATE_MUX_DIV>;
+			};
+
+			clk_gates19: clk_gates19 {
+				compatible = "rockchip,rk3188-gate-clk";
+				reg = <0x03a8 0x10>;
+					clocks =
+						<&dummy>,		<&dummy>,
+						<&dummy>,		<&dummy>,
+
+						<&dummy>,		<&aclk_hdcp>,
+						<&dummy>,		<&dummy>,
+
+						<&dummy>,		<&dummy>,
+						<&dummy>,		<&dummy>,
+
+						<&dummy>,		<&dummy>,
+						<&dummy>,		<&dummy>;
+
+					clock-output-names =
+						"reserved",		"reserved",
+						"reserved",		"reserved",
+
+						"reserved",		"aclk_hdcp",
+						"reserved",		"reserved",
+
+						"reserved",		"reserved",
+						"reserved",		"reserved",
+
+						"reserved",		"reserved",
+						"reserved",		"reserved";
+
+						rockchip,suspend-clkgating-setting=<0x0 0x0>;
+						#clock-cells = <1>;
+			};
+		};
 	};
 };
diff --git a/drivers/clk/rockchip/clk.c b/drivers/clk/rockchip/clk.c
index aaad37e..54d5d94 100755
--- a/drivers/clk/rockchip/clk.c
+++ b/drivers/clk/rockchip/clk.c
@@ -20,6 +20,7 @@
 #include <linux/of_address.h>
 #include <linux/clk-private.h>
 #include <asm/io.h>
+#include <linux/rockchip/cpu.h>
 
 #include "clk-ops.h"
 #include "clk-pll.h"
@@ -274,9 +275,12 @@ static int rkclk_init_divinfo(struct device_node *np, void __iomem *addr)
 		goto out;
 
 	divinfo->parent_name = of_clk_get_parent_name(np, 0);
+	
+	if ((strcmp(divinfo->clk_name, "hclk_vio") == 0) && (soc_is_rk3288w()))
+		divinfo->parent_name = "aclk_vio1";	
 
 	divinfo->np = np;
-
+	
 	ret = of_property_read_u32(np, "rockchip,clkops-idx",
 			&divinfo->clkops_idx);
 	if (ret != 0) {
@@ -1050,6 +1054,47 @@ out:
 	return ret;
 }
 
+
+static int __init rkclk_init_special_regs(struct device_node *np)
+{
+        struct device_node *node;
+        const char *compatible;
+        void __iomem *reg = 0;
+        int ret = 0;
+
+
+        for_each_available_child_of_node(np, node) {
+                clk_debug("\n");
+                of_property_read_string(node, "compatible", &compatible);
+                if (strcmp(compatible, "rockchip,rk3188-mux-con") == 0) {
+                        reg = of_iomap(node, 0);
+                        ret = rkclk_init_muxinfo(node, reg);
+                        if (ret != 0) {
+                                clk_err("%s: init mux con err\n", __func__);
+                                goto out;
+                        }
+                } else if (strcmp(compatible, "rockchip,rk3188-div-con") == 0) {
+                        reg = of_iomap(node, 0);
+                        ret = rkclk_init_divinfo(node, reg);
+                        if (ret != 0) {
+                                clk_err("%s: init div con err\n", __func__);
+                                goto out;
+                        }
+                } else if (strcmp(compatible, "rockchip,rk3188-gate-clk") == 0) {
+                        reg = of_iomap(node, 0);
+                        ret = rkclk_init_gatecon(node);
+                        if (ret != 0) {
+                                clk_err("%s: init gate con err\n", __func__);
+                                goto out;
+                        }
+                }
+        }
+
+out:
+        return ret;
+}
+
+
 static int __init rkclk_init_pd(struct device_node *np)
 {
 	struct device_node *node = NULL;
@@ -1477,7 +1522,12 @@ static void rkclk_add_provider(struct device_node *np)
 			for_each_available_child_of_node(node, node_prd) {
 				 _rkclk_add_provider(node_prd);
 			}
-		} else {
+		} else if (strcmp(compatible, "rockchip,rk-clock-special-regs") == 0) {
+                        if (rkclk_init_special_regs(node) != 0) {
+                                clk_err("%s: init special reg err\n", __func__);
+                                return;
+                        }
+                } else {
 			clk_err("%s: unknown\n", __func__);
 		}
 	}
-- 
1.7.9.5

