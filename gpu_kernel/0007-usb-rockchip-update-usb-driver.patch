From 53cf4c921986f04a3e13d476b240c3015c5e5405 Mon Sep 17 00:00:00 2001
From: huang zhibao <hzb@rock-chips.com>
Date: Thu, 25 Aug 2016 17:15:26 +0800
Subject: [PATCH 07/11] usb: rockchip: update usb driver

Conflicts:

	drivers/usb/host/ehci-rockchip.c
---
 drivers/usb/host/ehci-rkhsic.c   |  390 --------------------------------------
 drivers/usb/host/ehci-rockchip.c |   12 --
 drivers/usb/host/ehci-sysfs.c    |    8 +-
 drivers/usb/host/xhci-hub.c      |   13 +-
 drivers/usb/host/xhci-mem.c      |    8 +-
 drivers/usb/host/xhci-ring.c     |   82 ++++++--
 drivers/usb/host/xhci.c          |   11 +-
 drivers/usb/host/xhci.h          |    3 +-
 8 files changed, 92 insertions(+), 435 deletions(-)
 mode change 100644 => 100755 drivers/usb/host/ehci-hub.c
 mode change 100644 => 100755 drivers/usb/host/ehci-pci.c
 mode change 100644 => 100755 drivers/usb/host/ehci-platform.c
 delete mode 100755 drivers/usb/host/ehci-rkhsic.c
 mode change 100644 => 100755 drivers/usb/host/ehci-sysfs.c
 mode change 100644 => 100755 drivers/usb/host/ehci1-rockchip.c
 mode change 100644 => 100755 drivers/usb/host/isp116x-hcd.c
 mode change 100644 => 100755 drivers/usb/host/ohci-platform.c
 mode change 100644 => 100755 drivers/usb/host/ohci-q.c
 mode change 100644 => 100755 drivers/usb/host/oxu210hp-hcd.c
 mode change 100644 => 100755 drivers/usb/host/r8a66597-hcd.c
 mode change 100644 => 100755 drivers/usb/host/sl811-hcd.c
 mode change 100644 => 100755 drivers/usb/host/xhci-hub.c
 mode change 100644 => 100755 drivers/usb/host/xhci.h

diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c
old mode 100644
new mode 100755
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
old mode 100644
new mode 100755
diff --git a/drivers/usb/host/ehci-platform.c b/drivers/usb/host/ehci-platform.c
old mode 100644
new mode 100755
diff --git a/drivers/usb/host/ehci-rkhsic.c b/drivers/usb/host/ehci-rkhsic.c
deleted file mode 100755
index 659bcf0..0000000
--- a/drivers/usb/host/ehci-rkhsic.c
+++ /dev/null
@@ -1,390 +0,0 @@
-/* ehci-msm.c - HSUSB Host Controller Driver Implementation
- *
- * Copyright (c) 2008-2011, Code Aurora Forum. All rights reserved.
- *
- * Partly derived from ehci-fsl.c and ehci-hcd.c
- * Copyright (c) 2000-2004 by David Brownell
- * Copyright (c) 2005 MontaVista Software
- *
- * All source code in this file is licensed under the following license except
- * where indicated.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- *
- * See the GNU General Public License for more details.
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, you can find it at http://www.fsf.org
- */
-
-# include <linux/platform_device.h>
-# include <linux/clk.h>
-# include <linux/err.h>
-# include <linux/device.h>
-# include <linux/of.h>
-# include <linux/of_platform.h>
-# include "ehci.h"
-# include "../dwc_otg_310/usbdev_rk.h"
-
-static int rkhsic_status = 1;
-static struct ehci_hcd *g_hsic_ehci;
-#define HSIC_EHCI_PRINT(x...)	printk(KERN_INFO "HSIC_EHCI: " x)
-
-static struct rkehci_pdata_id rkhsic_pdata[] = {
-	{
-	 .name = "rk3188-hsic",
-	 .pdata = &rkhsic_pdata_rk3188,
-	 },
-	{
-	 .name = "rk3288-hsic",
-	 .pdata = &rkhsic_pdata_rk3288,
-	 },
-	{},
-};
-
-static void ehci_rkhsic_port_power(struct ehci_hcd *ehci, int is_on)
-{
-	unsigned port;
-
-	if (!HCS_PPC(ehci->hcs_params))
-		return;
-
-	ehci_dbg(ehci, "...power%s ports...\n", is_on ? "up" : "down");
-	for (port = HCS_N_PORTS(ehci->hcs_params); port > 0;)
-		(void)ehci_hub_control(ehci_to_hcd(ehci),
-				       is_on ? SetPortFeature :
-				       ClearPortFeature, USB_PORT_FEAT_POWER,
-				       port--, NULL, 0);
-	/* Flush those writes */
-	ehci_readl(ehci, &ehci->regs->command);
-	msleep(20);
-}
-
-static struct hc_driver rk_hsic_driver = {
-	.description = hcd_name,
-	.product_desc = "Rockchip On-Chip HSIC EHCI Host Controller",
-	.hcd_priv_size = sizeof(struct ehci_hcd),
-
-	/*
-	 * generic hardware linkage
-	 */
-	.irq = ehci_irq,
-	.flags = HCD_USB2 | HCD_MEMORY,
-
-	.reset = ehci_init,
-	.start = ehci_run,
-
-	.stop = ehci_stop,
-	.shutdown = ehci_shutdown,
-
-	/*
-	 * managing i/o requests and associated device resources
-	 */
-	.urb_enqueue = ehci_urb_enqueue,
-	.urb_dequeue = ehci_urb_dequeue,
-	.endpoint_disable = ehci_endpoint_disable,
-	.endpoint_reset = ehci_endpoint_reset,
-	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
-
-	/*
-	 * scheduling support
-	 */
-	.get_frame_number = ehci_get_frame,
-
-	/*
-	 * root hub support
-	 */
-	.hub_status_data = ehci_hub_status_data,
-	.hub_control = ehci_hub_control,
-	.relinquish_port = ehci_relinquish_port,
-	.port_handed_over = ehci_port_handed_over,
-
-	/*
-	 * PM support
-	 */
-#ifdef CONFIG_PM
-	.bus_suspend = ehci_bus_suspend,
-	.bus_resume = ehci_bus_resume,
-#endif
-};
-
-static ssize_t ehci_rkhsic_power_show(struct device *_dev,
-				      struct device_attribute *attr, char *buf)
-{
-	return sprintf(buf, "%d\n", rkhsic_status);
-}
-
-static ssize_t ehci_rkhsic_power_store(struct device *_dev,
-				       struct device_attribute *attr,
-				       const char *buf, size_t count)
-{
-	uint32_t val = simple_strtoul(buf, NULL, 16);
-	struct usb_hcd *hcd = dev_get_drvdata(_dev);
-	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
-	struct rkehci_platform_data *pldata = _dev->platform_data;
-
-	printk("%s: %d setting to: %d\n", __func__, rkhsic_status, val);
-	if (val == rkhsic_status)
-		goto out;
-
-	rkhsic_status = val;
-	switch (val) {
-	case 0:	/* power down */
-		ehci_rkhsic_port_power(ehci, 0);
-		writel_relaxed(0, hcd->regs + 0xb0);
-		dsb();
-		msleep(5);
-		usb_remove_hcd(hcd);
-		break;
-	case 1:	/* power on */
-		pldata->soft_reset(pldata, RST_POR);
-		usb_add_hcd(hcd, hcd->irq, IRQF_DISABLED | IRQF_SHARED);
-
-		ehci_rkhsic_port_power(ehci, 1);
-		writel_relaxed(1, hcd->regs + 0xb0);
-		writel_relaxed(0x1d4d, hcd->regs + 0x90);
-		writel_relaxed(0x4, hcd->regs + 0xa0);
-		dsb();
-		break;
-	default:
-		break;
-	}
-out:
-	return count;
-}
-
-static DEVICE_ATTR(ehci_rkhsic_power, S_IRUGO | S_IWUSR, ehci_rkhsic_power_show,
-		   ehci_rkhsic_power_store);
-
-static ssize_t hsic_debug_show(struct device *_dev,
-			       struct device_attribute *attr, char *buf)
-{
-	volatile uint32_t *addr;
-
-	HSIC_EHCI_PRINT("******** EHCI Capability Registers **********\n");
-	addr = &g_hsic_ehci->caps->hc_capbase;
-	HSIC_EHCI_PRINT("HCIVERSION / CAPLENGTH  @0x%08x:  0x%08x\n",
-			(uint32_t) addr, readl_relaxed(addr));
-	addr = &g_hsic_ehci->caps->hcs_params;
-	HSIC_EHCI_PRINT("HCSPARAMS               @0x%08x:  0x%08x\n",
-			(uint32_t) addr, readl_relaxed(addr));
-	addr = &g_hsic_ehci->caps->hcc_params;
-	HSIC_EHCI_PRINT("HCCPARAMS               @0x%08x:  0x%08x\n",
-			(uint32_t) addr, readl_relaxed(addr));
-	HSIC_EHCI_PRINT("********* EHCI Operational Registers *********\n");
-	addr = &g_hsic_ehci->regs->command;
-	HSIC_EHCI_PRINT("USBCMD                  @0x%08x:  0x%08x\n",
-			(uint32_t) addr, readl_relaxed(addr));
-	addr = &g_hsic_ehci->regs->status;
-	HSIC_EHCI_PRINT("USBSTS                  @0x%08x:  0x%08x\n",
-			(uint32_t) addr, readl_relaxed(addr));
-	addr = &g_hsic_ehci->regs->intr_enable;
-	HSIC_EHCI_PRINT("USBINTR                 @0x%08x:  0x%08x\n",
-			(uint32_t) addr, readl_relaxed(addr));
-	addr = &g_hsic_ehci->regs->frame_index;
-	HSIC_EHCI_PRINT("FRINDEX                 @0x%08x:  0x%08x\n",
-			(uint32_t) addr, readl_relaxed(addr));
-	addr = &g_hsic_ehci->regs->segment;
-	HSIC_EHCI_PRINT("CTRLDSSEGMENT           @0x%08x:  0x%08x\n",
-			(uint32_t) addr, readl_relaxed(addr));
-	addr = &g_hsic_ehci->regs->frame_list;
-	HSIC_EHCI_PRINT("PERIODICLISTBASE        @0x%08x:  0x%08x\n",
-			(uint32_t) addr, readl_relaxed(addr));
-	addr = &g_hsic_ehci->regs->async_next;
-	HSIC_EHCI_PRINT("ASYNCLISTADDR           @0x%08x:  0x%08x\n",
-			(uint32_t) addr, readl_relaxed(addr));
-	addr = &g_hsic_ehci->regs->configured_flag;
-	HSIC_EHCI_PRINT("CONFIGFLAG              @0x%08x:  0x%08x\n",
-			(uint32_t) addr, readl_relaxed(addr));
-	addr = g_hsic_ehci->regs->port_status;
-	HSIC_EHCI_PRINT("PORTSC                  @0x%08x:  0x%08x\n",
-			(uint32_t) addr, readl_relaxed(addr));
-	return sprintf(buf, "HSIC_EHCI Registers Dump\n");
-}
-
-static DEVICE_ATTR(hsic_debug_ehci, S_IRUGO, hsic_debug_show, NULL);
-
-static struct of_device_id rk_hsic_of_match[] = {
-	{
-	 .compatible = "rockchip,rk3188_rk_hsic_host",
-	 .data = &rkhsic_pdata[RK3188_USB_CTLR],
-	 },
-	{
-	 .compatible = "rockchip,rk3288_rk_hsic_host",
-	 .data = &rkhsic_pdata[RK3288_USB_CTLR],
-	 },
-	{},
-};
-
-MODULE_DEVICE_TABLE(of, rk_hsic_of_match);
-
-static int ehci_rkhsic_probe(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd;
-	struct ehci_hcd *ehci;
-	struct resource *res;
-	struct device *dev = &pdev->dev;
-	struct rkehci_platform_data *pldata;
-	int ret;
-	int retval = 0;
-	static u64 usb_dmamask = 0xffffffffUL;
-	struct device_node *node = pdev->dev.of_node;
-	struct rkehci_pdata_id *p;
-	const struct of_device_id *match =
-	    of_match_device(of_match_ptr(rk_hsic_of_match), &pdev->dev);
-
-	dev_dbg(&pdev->dev, "ehci_rkhsic proble\n");
-
-	if (match) {
-		p = (struct rkehci_pdata_id *)match->data;
-	} else {
-		dev_err(dev, "ehci_rkhsic match failed\n");
-		return -EINVAL;
-	}
-
-	dev->platform_data = p->pdata;
-	pldata = dev->platform_data;
-	pldata->dev = dev;
-
-	if (!node) {
-		dev_err(dev, "device node not found\n");
-		return -EINVAL;
-	}
-
-	dev->dma_mask = &usb_dmamask;
-
-	retval = device_create_file(dev, &dev_attr_ehci_rkhsic_power);
-	retval = device_create_file(dev, &dev_attr_hsic_debug_ehci);
-	hcd = usb_create_hcd(&rk_hsic_driver, &pdev->dev, dev_name(&pdev->dev));
-	if (!hcd) {
-		dev_err(&pdev->dev, "Unable to create HCD\n");
-		return -ENOMEM;
-	}
-
-	if (pldata->hw_init)
-		pldata->hw_init();
-
-	if (pldata->clock_init) {
-		pldata->clock_init(pldata);
-		pldata->clock_enable(pldata, 1);
-	}
-
-	if (pldata->soft_reset)
-		pldata->soft_reset(pldata, RST_POR);;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(&pdev->dev, "Unable to get memory resource\n");
-		ret = -ENODEV;
-		goto put_hcd;
-	}
-
-	hcd->rsrc_start = res->start;
-	hcd->rsrc_len = resource_size(res);
-	hcd->regs = devm_ioremap_resource(dev, res);
-
-	if (!hcd->regs) {
-		dev_err(&pdev->dev, "ioremap failed\n");
-		ret = -ENOMEM;
-		goto put_hcd;
-	}
-
-	hcd->irq = platform_get_irq(pdev, 0);
-	if (hcd->irq < 0) {
-		dev_err(&pdev->dev, "Unable to get IRQ resource\n");
-		ret = hcd->irq;
-		goto put_hcd;
-	}
-
-	ehci = hcd_to_ehci(hcd);
-	ehci->caps = hcd->regs;
-	ehci->regs = hcd->regs + 0x10;
-	printk("%s %p %p\n", __func__, ehci->caps, ehci->regs);
-
-	dbg_hcs_params(ehci, "reset");
-	dbg_hcc_params(ehci, "reset");
-
-	ehci->hcs_params = readl(&ehci->caps->hcs_params);
-
-	ret = usb_add_hcd(hcd, hcd->irq, IRQF_DISABLED | IRQF_SHARED);
-	if (ret) {
-		dev_err(&pdev->dev, "Failed to add USB HCD\n");
-		goto put_hcd;
-	}
-
-	g_hsic_ehci = ehci;
-	ehci_rkhsic_port_power(ehci, 1);
-	writel_relaxed(1, hcd->regs + 0xb0);
-	writel_relaxed(0x1d4d, hcd->regs + 0x90);
-	writel_relaxed(0x4, hcd->regs + 0xa0);
-	dsb();
-
-	printk("%s ok\n", __func__);
-
-	return 0;
-
-put_hcd:
-	if (pldata->clock_enable)
-		pldata->clock_enable(pldata, 0);
-	usb_put_hcd(hcd);
-
-	return ret;
-}
-
-static int ehci_rkhsic_remove(struct platform_device *pdev)
-{
-	struct usb_hcd *hcd = platform_get_drvdata(pdev);
-
-	usb_put_hcd(hcd);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM
-static int ehci_rkhsic_pm_suspend(struct device *dev)
-{
-	struct usb_hcd *hcd = dev_get_drvdata(dev);
-	bool do_wakeup = device_may_wakeup(dev);
-	int ret;
-
-	dev_dbg(dev, "ehci-rkhsic PM suspend\n");
-	ret = ehci_suspend(hcd, do_wakeup);
-
-	return ret;
-}
-
-static int ehci_rkhsic_pm_resume(struct device *dev)
-{
-	struct usb_hcd *hcd = dev_get_drvdata(dev);
-
-	dev_dbg(dev, "ehci-rkhsic PM resume\n");
-	ehci_resume(hcd, false);
-
-	return 0;
-}
-#else
-#define ehci_rkhsic_pm_suspend	NULL
-#define ehci_rkhsic_pm_resume	NULL
-#endif
-
-static const struct dev_pm_ops ehci_rkhsic_dev_pm_ops = {
-	.suspend = ehci_rkhsic_pm_suspend,
-	.resume = ehci_rkhsic_pm_resume,
-};
-
-static struct platform_driver ehci_rkhsic_driver = {
-	.probe = ehci_rkhsic_probe,
-	.remove = ehci_rkhsic_remove,
-	.driver = {
-		   .name = "rockchip_hsic_host",
-		   .of_match_table = of_match_ptr(rk_hsic_of_match),
-#ifdef CONFIG_PM
-		   .pm = &ehci_rkhsic_dev_pm_ops,
-#endif
-		   },
-};
diff --git a/drivers/usb/host/ehci-rockchip.c b/drivers/usb/host/ehci-rockchip.c
index 425a762..a9e9f8a 100755
--- a/drivers/usb/host/ehci-rockchip.c
+++ b/drivers/usb/host/ehci-rockchip.c
@@ -248,22 +248,10 @@ static ssize_t test_sq_store(struct device *dev,
 static DEVICE_ATTR(test_sq, S_IWUSR, NULL, test_sq_store);
 
 static struct of_device_id rk_ehci_of_match[] = {
-#ifdef CONFIG_ARM
 	{
 	 .compatible = "rockchip,rk3288_rk_ehci_host",
 	 .data = &rkehci_pdata_rk3288,
 	 },
-	{
-	 .compatible = "rockchip,rk3126_ehci",
-	 .data = &usb20ehci_pdata_rk3126,
-	 },
-#endif
-#ifdef CONFIG_ARM64
-	{
-	 .compatible = "rockchip,rk3368_ehci",
-	 .data = &usb20ehci_pdata_rk3368,
-	 },
-#endif
 	{},
 };
 
diff --git a/drivers/usb/host/ehci-sysfs.c b/drivers/usb/host/ehci-sysfs.c
old mode 100644
new mode 100755
index 14ced00..0659024
--- a/drivers/usb/host/ehci-sysfs.c
+++ b/drivers/usb/host/ehci-sysfs.c
@@ -29,7 +29,7 @@ static ssize_t show_companion(struct device *dev,
 	int			count = PAGE_SIZE;
 	char			*ptr = buf;
 
-	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));
+	ehci = hcd_to_ehci(dev_get_drvdata(dev));
 	nports = HCS_N_PORTS(ehci->hcs_params);
 
 	for (index = 0; index < nports; ++index) {
@@ -54,7 +54,7 @@ static ssize_t store_companion(struct device *dev,
 	struct ehci_hcd		*ehci;
 	int			portnum, new_owner;
 
-	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));
+	ehci = hcd_to_ehci(dev_get_drvdata(dev));
 	new_owner = PORT_OWNER;		/* Owned by companion */
 	if (sscanf(buf, "%d", &portnum) != 1)
 		return -EINVAL;
@@ -85,7 +85,7 @@ static ssize_t show_uframe_periodic_max(struct device *dev,
 	struct ehci_hcd		*ehci;
 	int			n;
 
-	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));
+	ehci = hcd_to_ehci(dev_get_drvdata(dev));
 	n = scnprintf(buf, PAGE_SIZE, "%d\n", ehci->uframe_periodic_max);
 	return n;
 }
@@ -102,7 +102,7 @@ static ssize_t store_uframe_periodic_max(struct device *dev,
 	unsigned long		flags;
 	ssize_t			ret;
 
-	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));
+	ehci = hcd_to_ehci(dev_get_drvdata(dev));
 	if (kstrtouint(buf, 0, &uframe_periodic_max) < 0)
 		return -EINVAL;
 
diff --git a/drivers/usb/host/ehci1-rockchip.c b/drivers/usb/host/ehci1-rockchip.c
old mode 100644
new mode 100755
diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c
old mode 100644
new mode 100755
diff --git a/drivers/usb/host/ohci-platform.c b/drivers/usb/host/ohci-platform.c
old mode 100644
new mode 100755
diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c
old mode 100644
new mode 100755
diff --git a/drivers/usb/host/oxu210hp-hcd.c b/drivers/usb/host/oxu210hp-hcd.c
old mode 100644
new mode 100755
diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c
old mode 100644
new mode 100755
diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c
old mode 100644
new mode 100755
diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c
old mode 100644
new mode 100755
index d939376..0f71c3a
--- a/drivers/usb/host/xhci-hub.c
+++ b/drivers/usb/host/xhci-hub.c
@@ -468,10 +468,13 @@ static void xhci_hub_report_link_state(struct xhci_hcd *xhci,
 	u32 pls = status_reg & PORT_PLS_MASK;
 
 	/* resume state is a xHCI internal state.
-	 * Do not report it to usb core.
+	 * Do not report it to usb core, instead, pretend to be U3,
+	 * thus usb core knows it's not ready for transfer
 	 */
-	if (pls == XDEV_RESUME)
+	if (pls == XDEV_RESUME) {
+		*status |= USB_SS_PORT_LS_U3;
 		return;
+	}
 
 	/* When the CAS bit is set then warm reset
 	 * should be performed on port
@@ -1045,10 +1048,10 @@ int xhci_bus_suspend(struct usb_hcd *hcd)
 	spin_lock_irqsave(&xhci->lock, flags);
 
 	if (hcd->self.root_hub->do_remote_wakeup) {
-		if (bus_state->resuming_ports) {
+		if (bus_state->resuming_ports ||	/* USB2 */
+		    bus_state->port_remote_wakeup) {	/* USB3 */
 			spin_unlock_irqrestore(&xhci->lock, flags);
-			xhci_dbg(xhci, "suspend failed because "
-						"a port is resuming\n");
+			xhci_dbg(xhci, "suspend failed because a port is resuming\n");
 			return -EBUSY;
 		}
 	}
diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c
index 677f032..87e82e6 100755
--- a/drivers/usb/host/xhci-mem.c
+++ b/drivers/usb/host/xhci-mem.c
@@ -1400,10 +1400,10 @@ int xhci_endpoint_init(struct xhci_hcd *xhci,
 		/* Attempt to use the ring cache */
 		if (virt_dev->num_rings_cached == 0)
 			return -ENOMEM;
+		virt_dev->num_rings_cached--;
 		virt_dev->eps[ep_index].new_ring =
 			virt_dev->ring_cache[virt_dev->num_rings_cached];
 		virt_dev->ring_cache[virt_dev->num_rings_cached] = NULL;
-		virt_dev->num_rings_cached--;
 		xhci_reinit_cached_ring(xhci, virt_dev->eps[ep_index].new_ring,
 					1, type);
 	}
@@ -1473,10 +1473,10 @@ int xhci_endpoint_init(struct xhci_hcd *xhci,
 	 * use Event Data TRBs, and we don't chain in a link TRB on short
 	 * transfers, we're basically dividing by 1.
 	 *
-	 * xHCI 1.0 specification indicates that the Average TRB Length should
-	 * be set to 8 for control endpoints.
+	 * xHCI 1.0 and 1.1 specification indicates that the Average TRB Length
+	 * should be set to 8 for control endpoints.
 	 */
-	if (usb_endpoint_xfer_control(&ep->desc) && xhci->hci_version == 0x100)
+	if (usb_endpoint_xfer_control(&ep->desc) && xhci->hci_version >= 0x100)
 		ep_ctx->tx_info |= cpu_to_le32(AVG_TRB_LENGTH_FOR_EP(8));
 	else
 		ep_ctx->tx_info |=
diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c
index bc7a886..4ba6974 100755
--- a/drivers/usb/host/xhci-ring.c
+++ b/drivers/usb/host/xhci-ring.c
@@ -85,7 +85,7 @@ dma_addr_t xhci_trb_virt_to_dma(struct xhci_segment *seg,
 		return 0;
 	/* offset in TRBs */
 	segment_offset = trb - seg->trbs;
-	if (segment_offset > TRBS_PER_SEGMENT)
+	if (segment_offset >= TRBS_PER_SEGMENT)
 		return 0;
 	return seg->dma + (segment_offset * sizeof(*trb));
 }
@@ -1669,6 +1669,9 @@ static void handle_port_status(struct xhci_hcd *xhci,
 		usb_hcd_resume_root_hub(hcd);
 	}
 
+	if (hcd->speed == HCD_USB3 && (temp & PORT_PLS_MASK) == XDEV_INACTIVE)
+		bus_state->port_remote_wakeup &= ~(1 << faked_port_index);
+
 	if ((temp & PORT_PLC) && (temp & PORT_PLS_MASK) == XDEV_RESUME) {
 		xhci_dbg(xhci, "port resume event for port %d\n", port_id);
 
@@ -2144,8 +2147,13 @@ static int process_isoc_td(struct xhci_hcd *xhci, struct xhci_td *td,
 		break;
 	case COMP_DEV_ERR:
 	case COMP_STALL:
+		frame->status = -EPROTO;
+		skip_td = true;
+		break;
 	case COMP_TX_ERR:
 		frame->status = -EPROTO;
+		if (event_trb != td->last_trb)
+			return 0;
 		skip_td = true;
 		break;
 	case COMP_STOP:
@@ -2762,7 +2770,7 @@ irqreturn_t xhci_irq(struct usb_hcd *hcd)
 		xhci_halt(xhci);
 hw_died:
 		spin_unlock(&xhci->lock);
-		return -ESHUTDOWN;
+		return IRQ_HANDLED;
 	}
 
 	/*
@@ -3159,9 +3167,11 @@ static int queue_bulk_sg_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 	struct xhci_td *td;
 	struct scatterlist *sg;
 	int num_sgs;
-	int trb_buff_len, this_sg_len, running_total;
+	int trb_buff_len, this_sg_len, running_total, ret;
 	unsigned int total_packet_count;
+	bool zero_length_needed;
 	bool first_trb;
+	int last_trb_num;
 	u64 addr;
 	bool more_trbs_coming;
 
@@ -3177,13 +3187,27 @@ static int queue_bulk_sg_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 	total_packet_count = DIV_ROUND_UP(urb->transfer_buffer_length,
 			usb_endpoint_maxp(&urb->ep->desc));
 
-	trb_buff_len = prepare_transfer(xhci, xhci->devs[slot_id],
+	ret = prepare_transfer(xhci, xhci->devs[slot_id],
 			ep_index, urb->stream_id,
 			num_trbs, urb, 0, mem_flags);
-	if (trb_buff_len < 0)
-		return trb_buff_len;
+	if (ret < 0)
+		return ret;
 
 	urb_priv = urb->hcpriv;
+
+	/* Deal with URB_ZERO_PACKET - need one more td/trb */
+	zero_length_needed = urb->transfer_flags & URB_ZERO_PACKET &&
+		urb_priv->length == 2;
+	if (zero_length_needed) {
+		num_trbs++;
+		xhci_dbg(xhci, "Creating zero length td.\n");
+		ret = prepare_transfer(xhci, xhci->devs[slot_id],
+				ep_index, urb->stream_id,
+				1, urb, 1, mem_flags);
+		if (ret < 0)
+			return ret;
+	}
+
 	td = urb_priv->td[0];
 
 	/*
@@ -3213,6 +3237,7 @@ static int queue_bulk_sg_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 		trb_buff_len = urb->transfer_buffer_length;
 
 	first_trb = true;
+	last_trb_num = zero_length_needed ? 2 : 1;
 	/* Queue the first TRB, even if it's zero-length */
 	do {
 		u32 field = 0;
@@ -3230,12 +3255,15 @@ static int queue_bulk_sg_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 		/* Chain all the TRBs together; clear the chain bit in the last
 		 * TRB to indicate it's the last TRB in the chain.
 		 */
-		if (num_trbs > 1) {
+		if (num_trbs > last_trb_num) {
 			field |= TRB_CHAIN;
-		} else {
-			/* FIXME - add check for ZERO_PACKET flag before this */
+		} else if (num_trbs == last_trb_num) {
 			td->last_trb = ep_ring->enqueue;
 			field |= TRB_IOC;
+		} else if (zero_length_needed && num_trbs == 1) {
+			trb_buff_len = 0;
+			urb_priv->td[1]->last_trb = ep_ring->enqueue;
+			field |= TRB_IOC;
 		}
 
 		/* Only set interrupt on short packet for IN endpoints */
@@ -3297,7 +3325,7 @@ static int queue_bulk_sg_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 		if (running_total + trb_buff_len > urb->transfer_buffer_length)
 			trb_buff_len =
 				urb->transfer_buffer_length - running_total;
-	} while (running_total < urb->transfer_buffer_length);
+	} while (num_trbs > 0);
 
 	check_trb_math(urb, num_trbs, running_total);
 	giveback_first_trb(xhci, slot_id, ep_index, urb->stream_id,
@@ -3315,7 +3343,9 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 	int num_trbs;
 	struct xhci_generic_trb *start_trb;
 	bool first_trb;
+	int last_trb_num;
 	bool more_trbs_coming;
+	bool zero_length_needed;
 	int start_cycle;
 	u32 field, length_field;
 
@@ -3346,7 +3376,6 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 		num_trbs++;
 		running_total += TRB_MAX_BUFF_SIZE;
 	}
-	/* FIXME: this doesn't deal with URB_ZERO_PACKET - need one more */
 
 	ret = prepare_transfer(xhci, xhci->devs[slot_id],
 			ep_index, urb->stream_id,
@@ -3355,6 +3384,20 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 		return ret;
 
 	urb_priv = urb->hcpriv;
+
+	/* Deal with URB_ZERO_PACKET - need one more td/trb */
+	zero_length_needed = urb->transfer_flags & URB_ZERO_PACKET &&
+		urb_priv->length == 2;
+	if (zero_length_needed) {
+		num_trbs++;
+		xhci_dbg(xhci, "Creating zero length td.\n");
+		ret = prepare_transfer(xhci, xhci->devs[slot_id],
+				ep_index, urb->stream_id,
+				1, urb, 1, mem_flags);
+		if (ret < 0)
+			return ret;
+	}
+
 	td = urb_priv->td[0];
 
 	/*
@@ -3376,7 +3419,7 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 		trb_buff_len = urb->transfer_buffer_length;
 
 	first_trb = true;
-
+	last_trb_num = zero_length_needed ? 2 : 1;
 	/* Queue the first TRB, even if it's zero-length */
 	do {
 		u32 remainder = 0;
@@ -3393,12 +3436,15 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 		/* Chain all the TRBs together; clear the chain bit in the last
 		 * TRB to indicate it's the last TRB in the chain.
 		 */
-		if (num_trbs > 1) {
+		if (num_trbs > last_trb_num) {
 			field |= TRB_CHAIN;
-		} else {
-			/* FIXME - add check for ZERO_PACKET flag before this */
+		} else if (num_trbs == last_trb_num) {
 			td->last_trb = ep_ring->enqueue;
 			field |= TRB_IOC;
+		} else if (zero_length_needed && num_trbs == 1) {
+			trb_buff_len = 0;
+			urb_priv->td[1]->last_trb = ep_ring->enqueue;
+			field |= TRB_IOC;
 		}
 
 		/* Only set interrupt on short packet for IN endpoints */
@@ -3436,7 +3482,7 @@ int xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 		trb_buff_len = urb->transfer_buffer_length - running_total;
 		if (trb_buff_len > TRB_MAX_BUFF_SIZE)
 			trb_buff_len = TRB_MAX_BUFF_SIZE;
-	} while (running_total < urb->transfer_buffer_length);
+	} while (num_trbs > 0);
 
 	check_trb_math(urb, num_trbs, running_total);
 	giveback_first_trb(xhci, slot_id, ep_index, urb->stream_id,
@@ -3503,8 +3549,8 @@ int xhci_queue_ctrl_tx(struct xhci_hcd *xhci, gfp_t mem_flags,
 	if (start_cycle == 0)
 		field |= 0x1;
 
-	/* xHCI 1.0 6.4.1.2.1: Transfer Type field */
-	if (xhci->hci_version == 0x100) {
+	/* xHCI 1.0/1.1 6.4.1.2.1: Transfer Type field */
+	if (xhci->hci_version >= 0x100) {
 		if (urb->transfer_buffer_length > 0) {
 			if (setup->bRequestType & USB_DIR_IN)
 				field |= TRB_TX_TYPE(TRB_DATA_IN);
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 10223f2..a3431e9 100755
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -139,7 +139,8 @@ static int xhci_start(struct xhci_hcd *xhci)
 				"waited %u microseconds.\n",
 				XHCI_MAX_HALT_USEC);
 	if (!ret)
-		xhci->xhc_state &= ~XHCI_STATE_HALTED;
+		xhci->xhc_state &= ~(XHCI_STATE_HALTED | XHCI_STATE_DYING);
+
 	return ret;
 }
 
@@ -1299,6 +1300,11 @@ int xhci_urb_enqueue(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags)
 
 	if (usb_endpoint_xfer_isoc(&urb->ep->desc))
 		size = urb->number_of_packets;
+	else if (usb_endpoint_is_bulk_out(&urb->ep->desc) &&
+	    urb->transfer_buffer_length > 0 &&
+	    urb->transfer_flags & URB_ZERO_PACKET &&
+	    !(urb->transfer_buffer_length % usb_endpoint_maxp(&urb->ep->desc)))
+		size = 2;
 	else
 		size = 1;
 
@@ -3356,6 +3362,9 @@ int xhci_discover_or_reset_device(struct usb_hcd *hcd, struct usb_device *udev)
 			return -EINVAL;
 	}
 
+	if (virt_dev->tt_info)
+		old_active_eps = virt_dev->tt_info->active_eps;
+
 	if (virt_dev->udev != udev) {
 		/* If the virt_dev and the udev does not match, this virt_dev
 		 * may belong to another udev.
diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
old mode 100644
new mode 100755
index 373d4da..deb2537
--- a/drivers/usb/host/xhci.h
+++ b/drivers/usb/host/xhci.h
@@ -280,6 +280,7 @@ struct xhci_op_regs {
 #define XDEV_U0		(0x0 << 5)
 #define XDEV_U2		(0x2 << 5)
 #define XDEV_U3		(0x3 << 5)
+#define XDEV_INACTIVE	(0x6 << 5)
 #define XDEV_RESUME	(0xf << 5)
 /* true: port has power (see HCC_PPC) */
 #define PORT_POWER	(1 << 9)
@@ -1237,7 +1238,7 @@ union xhci_trb {
  * since the command ring is 64-byte aligned.
  * It must also be greater than 16.
  */
-#define TRBS_PER_SEGMENT	64
+#define TRBS_PER_SEGMENT	256
 /* Allow two commands + a link TRB, along with any reserved command TRBs */
 #define MAX_RSVD_CMD_TRBS	(TRBS_PER_SEGMENT - 3)
 #define TRB_SEGMENT_SIZE	(TRBS_PER_SEGMENT*16)
-- 
1.7.9.5

