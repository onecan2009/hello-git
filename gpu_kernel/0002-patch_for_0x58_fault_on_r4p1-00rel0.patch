From d16a02e53a1b5a9f1ccfc40c1df3e10f865df29d Mon Sep 17 00:00:00 2001
From: cjp <service@t-firefly.com>
Date: Thu, 17 Nov 2016 16:05:18 +0800
Subject: [PATCH 02/11] =?UTF-8?q?=E6=B7=BB=E5=8A=A0=20patch=5Ffor=5F0x58=5Ff?=
 =?UTF-8?q?ault=5Fon=5Fr4p1-00rel0?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 drivers/gpu/arm/midgard/.gitignore                 |   46 ++++
 drivers/gpu/arm/midgard/Kbuild                     |    2 +-
 drivers/gpu/arm/midgard/custom_log.h               |  223 ++++++++++++++++
 drivers/gpu/arm/midgard/mali_base_hwconfig.h       |    7 +
 drivers/gpu/arm/midgard/mali_base_kernel.h         |   64 ++++-
 .../gpu/arm/midgard/mali_kbase_10969_workaround.c  |    8 +-
 .../gpu/arm/midgard/mali_kbase_config_defaults.h   |    2 +-
 drivers/gpu/arm/midgard/mali_kbase_core_linux.c    |   12 +-
 drivers/gpu/arm/midgard/mali_kbase_defs.h          |   79 +++++-
 drivers/gpu/arm/midgard/mali_kbase_device.c        |    1 +
 .../arm/midgard/mali_kbase_gpu_memory_debugfs.c    |    9 +-
 drivers/gpu/arm/midgard/mali_kbase_jd.c            |  187 ++++++++-----
 drivers/gpu/arm/midgard/mali_kbase_jm.c            |    1 +
 drivers/gpu/arm/midgard/mali_kbase_mem.c           |    6 +
 drivers/gpu/arm/midgard/mali_kbase_mem.h           |    7 +-
 drivers/gpu/arm/midgard/mali_kbase_mem_linux.c     |   17 +-
 drivers/gpu/arm/midgard/mali_kbase_mmu.c           |    4 +-
 drivers/gpu/arm/midgard/mali_kbase_pm.c            |   13 -
 drivers/gpu/arm/midgard/mali_kbase_pm_driver.c     |   20 +-
 drivers/gpu/arm/midgard/mali_kbase_pm_policy.c     |   22 +-
 drivers/gpu/arm/midgard/mali_kbase_replay.c        |    8 +-
 drivers/gpu/arm/midgard/mali_kbase_softjobs.c      |   19 +-
 drivers/gpu/arm/midgard/mali_kbase_uku.h           |   11 +-
 drivers/gpu/arm/midgard/mali_midg_regmap.h         |    1 +
 drivers/gpu/arm/midgard/platform/juno_soc/Kbuild   |   19 ++
 .../arm/midgard/platform/juno_soc/juno_mali_opp.c  |   73 +++++
 .../platform/juno_soc/mali_kbase_config_juno_soc.c |  134 ++++++++++
 .../platform/juno_soc/mali_kbase_config_platform.h |   33 +++
 .../arm/midgard/platform/vexpress_1xv7_a57/Kbuild  |   16 ++
 .../vexpress_1xv7_a57/mali_kbase_config_platform.h |   33 +++
 .../vexpress_1xv7_a57/mali_kbase_config_vexpress.c |  279 ++++++++++++++++++++
 31 files changed, 1221 insertions(+), 135 deletions(-)
 create mode 100755 drivers/gpu/arm/midgard/.gitignore
 create mode 100755 drivers/gpu/arm/midgard/custom_log.h
 create mode 100755 drivers/gpu/arm/midgard/platform/juno_soc/Kbuild
 create mode 100755 drivers/gpu/arm/midgard/platform/juno_soc/juno_mali_opp.c
 create mode 100755 drivers/gpu/arm/midgard/platform/juno_soc/mali_kbase_config_juno_soc.c
 create mode 100755 drivers/gpu/arm/midgard/platform/juno_soc/mali_kbase_config_platform.h
 create mode 100755 drivers/gpu/arm/midgard/platform/vexpress_1xv7_a57/Kbuild
 create mode 100755 drivers/gpu/arm/midgard/platform/vexpress_1xv7_a57/mali_kbase_config_platform.h
 create mode 100755 drivers/gpu/arm/midgard/platform/vexpress_1xv7_a57/mali_kbase_config_vexpress.c

diff --git a/drivers/gpu/arm/midgard/.gitignore b/drivers/gpu/arm/midgard/.gitignore
new file mode 100755
index 0000000..9259660
--- /dev/null
+++ b/drivers/gpu/arm/midgard/.gitignore
@@ -0,0 +1,46 @@
+*~
+*.swp
+*.swo
+*.swn
+*.bak
+*.log
+
+# ./kernel/
+# /out
+# *.sh
+
+# 忽略所有名称是 CVS 的目录.
+CVS/
+html/
+temp/
+
+*.back
+# *.rc
+*.bin
+*.rar
+*.bat
+*.BAT
+*.o
+# *.so
+*.a
+*.ko
+*.mod.c
+*.cmd
+*.mod
+*.order
+
+*.jar
+
+*.html
+*.vim
+
+temp.*
+tmp.*
+*.tmp
+*.temp
+*.dump
+
+*.udb
+*.sh
+tags
+
diff --git a/drivers/gpu/arm/midgard/Kbuild b/drivers/gpu/arm/midgard/Kbuild
index 33dc457..3cf2828 100755
--- a/drivers/gpu/arm/midgard/Kbuild
+++ b/drivers/gpu/arm/midgard/Kbuild
@@ -15,7 +15,7 @@
 
 
 # Driver version string which is returned to userspace via an ioctl
-MALI_RELEASE_NAME ?= "r4p1-02dev0"
+MALI_RELEASE_NAME ?= "r4p1-00rel0"
 
 # Paths required for build
 KBASE_PATH = $(src)
diff --git a/drivers/gpu/arm/midgard/custom_log.h b/drivers/gpu/arm/midgard/custom_log.h
new file mode 100755
index 0000000..018a0f6
--- /dev/null
+++ b/drivers/gpu/arm/midgard/custom_log.h
@@ -0,0 +1,223 @@
+/*  --------------------------------------------------------------------------------------------------------
+ *  File:   custom_log.h 
+ *
+ *  Desc:   ChenZhen 偏好的 log 输出的定制实现. 
+ *
+ *          -----------------------------------------------------------------------------------
+ *          < 习语 和 缩略语 > : 
+ *
+ *          -----------------------------------------------------------------------------------
+ *  Usage:		
+ *
+ *  Note:
+ *
+ *  Author: ChenZhen
+ *
+ *  --------------------------------------------------------------------------------------------------------
+ *  Version:
+ *          v1.0
+ *  --------------------------------------------------------------------------------------------------------
+ *  Log:
+	----Fri Nov 19 15:20:28 2010            v1.0
+ *        
+ *  --------------------------------------------------------------------------------------------------------
+ */
+
+
+#ifndef __CUSTOM_LOG_H__
+#define __CUSTOM_LOG_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* ---------------------------------------------------------------------------------------------------------
+ *  Include Files
+ * ---------------------------------------------------------------------------------------------------------
+ */
+#include <linux/kernel.h>
+
+
+/* ---------------------------------------------------------------------------------------------------------
+ *  Macros Definition 
+ * ---------------------------------------------------------------------------------------------------------
+ */
+    
+/** 若下列 macro 有被定义, 才 使能 log 输出. */
+// #define ENABLE_DEBUG_LOG
+
+/** .! : 若需要全局地关闭 D log, 可以使能下面的代码. */
+/*
+#undef ENABLE_DEBUG_LOG
+#warning "custom debug log is disabled globally!"
+*/
+
+#define LOGD(fmt, args...) \
+    printk(KERN_DEBUG fmt "\n", ## args)
+
+/*---------------------------------------------------------------------------*/
+    
+#ifdef ENABLE_VERBOSE_LOG
+/** Verbose log. */
+#define V(fmt, args...) \
+    { printk(KERN_DEBUG "V : [File] : %s; [Line] : %d; [Func] : %s(); " fmt "\n", __FILE__, __LINE__, __FUNCTION__, ## args); }
+#else
+#define  V(...)  ((void)0)
+#endif
+
+
+#ifdef ENABLE_DEBUG_LOG
+/** Debug log. */
+#define D(fmt, args...) \
+    /* { printk(KERN_DEBUG "D : [File] : %s; [Line] : %d; [Func] : %s(); " fmt "\n", __FILE__, __LINE__, __FUNCTION__, ## args); } */\
+    { printk("D : [File] : %s; [Line] : %d; [Func] : %s(); " fmt "\n", __FILE__, __LINE__, __FUNCTION__, ## args); }
+#else
+#define  D(...)  ((void)0)
+#endif
+
+#define I(fmt, args...) \
+    { printk(KERN_INFO "I : [File] : %s; [Line] : %d; [Func] : %s(); " fmt "\n", __FILE__, __LINE__, __FUNCTION__, ## args); }
+
+#define W(fmt, args...) \
+    { printk(KERN_WARNING "W : [File] : %s; [Line] : %d; [Func] : %s(); " fmt "\n", __FILE__, __LINE__, __FUNCTION__, ## args); }
+
+#define E(fmt, args...) \
+    { printk(KERN_ERR "E : [File] : %s; [Line] : %d; [Func] : %s(); " fmt "\n", __FILE__, __LINE__, __FUNCTION__, ## args); }
+
+/*-------------------------------------------------------*/
+
+/** 使用 D(), 以十进制的形式打印变量 'var' 的 value. */
+#define D_DEC(var)  D(#var " = %d.", var);
+
+#define E_DEC(var)  E(#var " = %d.", var);
+
+/** 使用 D(), 以十六进制的形式打印变量 'var' 的 value. */
+#define D_HEX(var)  D(#var " = 0x%x.", var);
+
+#define E_HEX(var)  E(#var " = 0x%x.", var);
+
+/** 使用 D(), 以十六进制的形式 打印指针类型变量 'ptr' 的 value. */
+#define D_PTR(ptr)  D(#ptr " = %p.", ptr);
+
+#define E_PTR(ptr)  E(#ptr " = %p.", ptr);
+
+/** 使用 D(), 打印 char 字串. */
+#define D_STR(pStr) \
+{\
+    if ( NULL == pStr )\
+    {\
+        D(#pStr" = NULL.");\
+    }\
+    else\
+    {\
+        D(#pStr" = '%s'.", pStr);\
+    }\
+}
+
+#define E_STR(pStr) \
+{\
+    if ( NULL == pStr )\
+    {\
+        E(#pStr" = NULL.");\
+    }\
+    else\
+    {\
+        E(#pStr" = '%s'.", pStr);\
+    }\
+}
+
+#ifdef ENABLE_DEBUG_LOG
+/**
+ * log 从 'pStart' 地址开始的 'len' 个字节的数据. 
+ */
+#define D_MEM(pStart, len) \
+    {\
+        int i = 0;\
+        char* p = (char*)pStart;\
+        D("dump memory from addr of '" #pStart "', from %p, length %d' : ", pStart, len); \
+        printk("\t\t");\
+        for ( i = 0; i < len ; i++ )\
+        {\
+            printk("0x%02x, ", p[i] );\
+        }\
+        printk("\n");\
+    }
+#else
+#define  D_MEM(...)  ((void)0)
+#endif
+
+/*-------------------------------------------------------*/
+
+#define EXIT_FOR_DEBUG \
+{\
+    E("To exit for debug.");\
+    return 1;\
+}
+
+/*-------------------------------------------------------*/
+
+/**
+ * 调用函数, 并检查返回值, 根据返回值决定是否跳转到指定的错误处理代码. 
+ * @param functionCall
+ *          对特定函数的调用, 该函数的返回值必须是 表征 成功 or err 的 整型数. 
+ *          这里, 被调用函数 "必须" 是被定义为 "返回 0 表示操作成功". 
+ * @param result
+ *		    用于记录函数返回的 error code 的 整型变量, 通常是 "ret" or "result" 等.
+ * @param label
+ *		    若函数返回错误, 程序将要跳转到的 错误处理处的 标号, 通常就是 "EXIT". 
+ */
+#define CHECK_FUNC_CALL(functionCall, result, label) \
+{\
+	if ( 0 != ( (result) = (functionCall) ) )\
+	{\
+		E("Function call returned error : " #result " = %d.", result);\
+		goto label;\
+	}\
+}
+
+/**
+ * 在特定条件下, 判定 error 发生, 对变量 'retVar' 设置 'errCode', 
+ * Log 输出对应的 Error Caution, 然后跳转 'label' 指定的代码处执行. 
+ * @param msg
+ *          纯字串形式的提示信息. 
+ * @param retVar
+ *		    标识函数执行状态或者结果的变量, 将被设置具体的 Error Code. 
+ *		    通常是 'ret' or 'result'. 
+ * @param errCode
+ *          表征特定 error 的常数标识, 通常是 宏的形态. 
+ * @param label
+ *          程序将要跳转到的错误处理代码的标号, 通常就是 'EXIT'. 
+ * @param args...
+ *          对应 'msgFmt' 实参中 '%s', '%d', ... 等 转换说明符 的具体可变长实参. 
+ */
+#define SET_ERROR_AND_JUMP(msgFmt, retVar, errCode, label, args...) \
+{\
+    E("To set '" #retVar "' to %d('" #errCode "'), because : " msgFmt, (errCode), ## args);\
+	(retVar) = (errCode);\
+	goto label;\
+}
+
+
+/* ---------------------------------------------------------------------------------------------------------
+ *  Types and Structures Definition
+ * ---------------------------------------------------------------------------------------------------------
+ */
+
+
+/* ---------------------------------------------------------------------------------------------------------
+ *  Global Functions' Prototype
+ * ---------------------------------------------------------------------------------------------------------
+ */
+
+
+/* ---------------------------------------------------------------------------------------------------------
+ *  Inline Functions Implementation 
+ * ---------------------------------------------------------------------------------------------------------
+ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __CUSTOM_LOG_H__ */
+
diff --git a/drivers/gpu/arm/midgard/mali_base_hwconfig.h b/drivers/gpu/arm/midgard/mali_base_hwconfig.h
index f7ee4a7..5f5c945 100755
--- a/drivers/gpu/arm/midgard/mali_base_hwconfig.h
+++ b/drivers/gpu/arm/midgard/mali_base_hwconfig.h
@@ -276,6 +276,9 @@ typedef enum base_hw_issue {
 	/* Write buffer can cause tile list corruption */
 	BASE_HW_ISSUE_11024,
 
+	/* Pause buffer can cause a fragment job hang */
+	BASE_HW_ISSUE_11035,
+
 	/* T76X hw issues */
 
 	/* Partial 16xMSAA support */
@@ -367,6 +370,7 @@ static const base_hw_issue base_hw_issues_t60x_r0p0_15dev0[] = {
 	BASE_HW_ISSUE_10995,
 	BASE_HW_ISSUE_11012,
 	BASE_HW_ISSUE_11020,
+	BASE_HW_ISSUE_11035,
 	/* List of hardware issues must end with BASE_HW_ISSUE_END */
 	BASE_HW_ISSUE_END
 };
@@ -403,6 +407,7 @@ static const base_hw_issue base_hw_issues_t60x_r0p0_eac[] = {
 	BASE_HW_ISSUE_10969,
 	BASE_HW_ISSUE_11012,
 	BASE_HW_ISSUE_11020,
+	BASE_HW_ISSUE_11035,
 	/* List of hardware issues must end with BASE_HW_ISSUE_END */
 	BASE_HW_ISSUE_END
 };
@@ -436,6 +441,7 @@ static const base_hw_issue base_hw_issues_t60x_r0p1[] = {
 	BASE_HW_ISSUE_10946,
 	BASE_HW_ISSUE_11012,
 	BASE_HW_ISSUE_11020,
+	BASE_HW_ISSUE_11035,
 	/* List of hardware issues must end with BASE_HW_ISSUE_END */
 	BASE_HW_ISSUE_END
 };
@@ -466,6 +472,7 @@ static const base_hw_issue base_hw_issues_t62x_r0p1[] = {
 	BASE_HW_ISSUE_11012,
 	BASE_HW_ISSUE_11020,
 	BASE_HW_ISSUE_11024,
+	BASE_HW_ISSUE_11035,
 	/* List of hardware issues must end with BASE_HW_ISSUE_END */
 	BASE_HW_ISSUE_END
 };
diff --git a/drivers/gpu/arm/midgard/mali_base_kernel.h b/drivers/gpu/arm/midgard/mali_base_kernel.h
index 4aff2bd..53e6431 100755
--- a/drivers/gpu/arm/midgard/mali_base_kernel.h
+++ b/drivers/gpu/arm/midgard/mali_base_kernel.h
@@ -316,6 +316,22 @@ struct base_mem_aliasing_info {
 };
 
 /**
+ * @brief Job dependency type.
+ *
+ * A flags field will be inserted into the atom structure to specify whether a dependency is a data or 
+ * ordering dependency (by putting it before/after 'core_req' in the structure it should be possible to add without 
+ * changing the structure size).
+ * When the flag is set for a particular dependency to signal that it is an ordering only dependency then 
+ * errors will not be propagated.
+ */
+typedef u8 base_jd_dep_type;
+
+
+#define BASE_JD_DEP_TYPE_INVALID  (0) 	/**< Invalid dependency */
+#define BASE_JD_DEP_TYPE_DATA     (1U << 0) 	/**< Data dependency */
+#define BASE_JD_DEP_TYPE_ORDER    (1U << 1) 	/**< Order dependency */
+
+/**
  * @brief Job chain hardware requirements.
  *
  * A job chain must specify what GPU features it needs to allow the
@@ -542,17 +558,23 @@ typedef struct base_jd_atom {
 
 typedef u8 base_atom_id; /**< Type big enough to store an atom number in */
 
+struct base_dependency {
+	base_atom_id  atom_id;               /**< An atom number */
+	base_jd_dep_type dependency_type;    /**< Dependency type */
+}; 
+
 typedef struct base_jd_atom_v2 {
 	mali_addr64 jc;			    /**< job-chain GPU address */
 	base_jd_udata udata;		    /**< user data */
 	kbase_pointer extres_list;	    /**< list of external resources */
 	u16 nr_extres;			    /**< nr of external resources */
 	base_jd_core_req core_req;	    /**< core requirements */
-	base_atom_id pre_dep[2];	    /**< pre-dependencies */
+	const struct base_dependency pre_dep[2]; /**< pre-dependencies, one need to use SETTER function to assign this field,
+	this is done in order to reduce possibility of improper assigment of a dependency field */
 	base_atom_id atom_number;	    /**< unique number to identify the atom */
 	s8 prio;			    /**< priority - smaller is higher priority */
 	u8 device_nr;			    /**< coregroup when BASE_JD_REQ_SPECIFIC_COHERENT_GROUP specified */
-	u8 padding[7];
+	u8 padding[5];
 } base_jd_atom_v2;
 
 #if BASE_LEGACY_JD_API
@@ -626,6 +648,44 @@ static INLINE base_syncset *base_jd_get_atom_syncset(base_jd_atom *atom, u16 n)
 }
 #endif				/* BASE_LEGACY_JD_API */
 
+
+/**
+ * @brief Setter for a dependency structure
+ *
+ * @param[in] dep          The kbase jd atom dependency to be initialized.
+ * @param     id           The atom_id to be assigned.
+ * @param     dep_type     The dep_type to be assigned.
+ *
+ */
+static INLINE void base_jd_atom_dep_set(const struct base_dependency* const_dep, base_atom_id id, base_jd_dep_type dep_type)
+{
+	struct base_dependency* dep;
+	
+	LOCAL_ASSERT(const_dep != NULL);
+	/* make sure we don't set not allowed combinations of atom_id/dependency_type */
+	LOCAL_ASSERT( ( id == 0 && dep_type == BASE_JD_DEP_TYPE_INVALID) || 
+				(id > 0 && dep_type != BASE_JD_DEP_TYPE_INVALID) );
+
+	dep = REINTERPRET_CAST(struct base_dependency*)const_dep;
+
+	dep->atom_id = id;
+	dep->dependency_type = dep_type;
+}
+
+/**
+ * @brief Make a copy of a dependency structure
+ *
+ * @param[in,out] dep          The kbase jd atom dependency to be written.
+ * @param[in]     from         The dependency to make a copy from.
+ *
+ */
+static INLINE void base_jd_atom_dep_copy(const struct base_dependency* const_dep, const struct base_dependency* from)
+{
+	LOCAL_ASSERT(const_dep != NULL);
+
+	base_jd_atom_dep_set(const_dep, from->atom_id, from->dependency_type);
+}
+
 /**
  * @brief Soft-atom fence trigger setup.
  *
diff --git a/drivers/gpu/arm/midgard/mali_kbase_10969_workaround.c b/drivers/gpu/arm/midgard/mali_kbase_10969_workaround.c
index b081430..6d52dcf 100755
--- a/drivers/gpu/arm/midgard/mali_kbase_10969_workaround.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_10969_workaround.c
@@ -44,9 +44,12 @@ int kbasep_10969_workaround_clamp_coordinates(kbase_jd_atom *katom)
 {
 	struct device *dev = katom->kctx->kbdev->dev;
 	u32   clamped = 0;
-	dev_warn(dev,"Called TILE_RANGE_FAULT workaround clamping function. \n");
+	dev_warn(dev, "Called TILE_RANGE_FAULT workaround clamping function.\n");
 	if (katom->core_req & BASE_JD_REQ_FS){
-		kbase_va_region * region = kbase_region_tracker_find_region_enclosing_address(katom->kctx, katom->jc );
+		kbase_va_region *region;
+
+		kbase_gpu_vm_lock(katom->kctx);
+		region = kbase_region_tracker_find_region_enclosing_address(katom->kctx, katom->jc);
 
 		if (region){
 			phys_addr_t * page_array = kbase_get_phy_pages(region);
@@ -171,6 +174,7 @@ int kbasep_10969_workaround_clamp_coordinates(kbase_jd_atom *katom)
 				kunmap_atomic(page_1);
 			}
 		}
+		kbase_gpu_vm_unlock(katom->kctx);
 	}
 	return clamped;
 }
diff --git a/drivers/gpu/arm/midgard/mali_kbase_config_defaults.h b/drivers/gpu/arm/midgard/mali_kbase_config_defaults.h
index 88dcff3..30fdb58 100755
--- a/drivers/gpu/arm/midgard/mali_kbase_config_defaults.h
+++ b/drivers/gpu/arm/midgard/mali_kbase_config_defaults.h
@@ -164,7 +164,7 @@
 /*** Begin Power Manager defaults */
 
 /* Milliseconds */
-#define DEFAULT_PM_DVFS_FREQ 50
+#define DEFAULT_PM_DVFS_FREQ 20
 
 /**
  * Default poweroff tick granuality, in nanoseconds
diff --git a/drivers/gpu/arm/midgard/mali_kbase_core_linux.c b/drivers/gpu/arm/midgard/mali_kbase_core_linux.c
index 399ac94..5af0ed1 100755
--- a/drivers/gpu/arm/midgard/mali_kbase_core_linux.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_core_linux.c
@@ -85,7 +85,7 @@ EXPORT_SYMBOL(shared_kernel_test_data);
 #endif /* MALI_UNIT_TEST */
 
 #define KBASE_DRV_NAME "mali"
-#define ROCKCHIP_VERSION 5
+#define ROCKCHIP_VERSION 0x06
 static const char kbase_drv_name[] = KBASE_DRV_NAME;
 
 static int kbase_dev_nr;
@@ -154,6 +154,7 @@ mali_error kbasep_kds_allocate_resource_list_data(kbase_context *kctx, base_exte
 		return MALI_ERROR_OUT_OF_MEMORY;
 	}
 
+	kbase_gpu_vm_lock(kctx);
 	for (res_id = 0; res_id < num_elems; res_id++, res++) {
 		int exclusive;
 		kbase_va_region *reg;
@@ -188,6 +189,7 @@ mali_error kbasep_kds_allocate_resource_list_data(kbase_context *kctx, base_exte
 		if (exclusive)
 			set_bit(res_id, resources_list->kds_access_bitmap);
 	}
+	kbase_gpu_vm_unlock(kctx);
 
 	/* did the loop run to completion? */
 	if (res_id == num_elems)
@@ -922,7 +924,7 @@ static int kbase_release(struct inode *inode, struct file *filp)
 	struct kbase_device *kbdev = kctx->kbdev;
 	kbasep_kctx_list_element *element, *tmp;
 	mali_bool found_element = MALI_FALSE;
-
+	
 	mutex_lock(&kbdev->kctx_list_lock);
 	list_for_each_entry_safe(element, tmp, &kbdev->kctx_list, link) {
 		if (element->kctx == kctx) {
@@ -2615,6 +2617,12 @@ static int kbase_platform_device_probe(struct platform_device *pdev)
 	kbase_platform_config *config;
 	int attribute_count;
 
+        printk(KERN_INFO "arm_release_ver of this mali_ko is '%s', rk_ko_ver is '%d', built at '%s', on '%s'.",
+                MALI_RELEASE_NAME,
+                ROCKCHIP_VERSION,
+                __TIME__,
+                __DATE__);
+
 /*#ifdef CONFIG_MALI_PLATFORM_FAKE*/
 #if 1
 /*defined(CONFIG_MALI_PLATFORM_FAKE) || defined(CONFIG_MALI_PLATFORM_FAKE_MODULE)*/
diff --git a/drivers/gpu/arm/midgard/mali_kbase_defs.h b/drivers/gpu/arm/midgard/mali_kbase_defs.h
index 52300d2..e01d01a 100755
--- a/drivers/gpu/arm/midgard/mali_kbase_defs.h
+++ b/drivers/gpu/arm/midgard/mali_kbase_defs.h
@@ -217,6 +217,82 @@ typedef enum {
 
 typedef struct kbase_jd_atom kbase_jd_atom;
 
+struct kbase_jd_atom_dependency
+{
+	struct kbase_jd_atom *atom;
+	u8 dep_type;
+};
+
+/**
+ * @brief The function retrieves a read-only reference to the atom field from 
+ * the  kbase_jd_atom_dependency structure
+ *
+ * @param[in] dep kbase jd atom dependency.
+ *
+ * @return readonly reference to dependent ATOM.
+ */
+static INLINE const struct kbase_jd_atom* const kbase_jd_katom_dep_atom(const struct kbase_jd_atom_dependency* dep)
+{
+	LOCAL_ASSERT(dep != NULL);
+	
+	return (const struct kbase_jd_atom* const )(dep->atom);
+}
+ 
+/**
+ * @brief The function retrieves a read-only reference to the dependency type field from 
+ * the  kbase_jd_atom_dependency structure
+ *
+ * @param[in] dep kbase jd atom dependency.
+ *
+ * @return A dependency type value.
+ */
+static INLINE const u8 kbase_jd_katom_dep_type(const struct kbase_jd_atom_dependency* dep)
+{
+	LOCAL_ASSERT(dep != NULL);
+
+	return dep->dep_type;
+}
+
+/**
+ * @brief Setter macro for dep_atom array entry in kbase_jd_atom
+ *
+ * @param[in] dep    The kbase jd atom dependency.
+ * @param[in] a      The ATOM to be set as a dependency.
+ * @param     type   The ATOM dependency type to be set.
+ *
+ */
+static INLINE void kbase_jd_katom_dep_set(const struct kbase_jd_atom_dependency* const_dep, 
+	struct kbase_jd_atom * a,
+	u8 type)
+{
+	struct kbase_jd_atom_dependency* dep;
+	
+	LOCAL_ASSERT(const_dep != NULL);
+
+	dep = (REINTERPRET_CAST(struct kbase_jd_atom_dependency* )const_dep);
+
+	dep->atom = a;
+	dep->dep_type = type; 
+}
+
+/**
+ * @brief Setter macro for dep_atom array entry in kbase_jd_atom
+ *
+ * @param[in] dep    The kbase jd atom dependency to be cleared.
+ *
+ */
+static INLINE void kbase_jd_katom_dep_clear(const struct kbase_jd_atom_dependency* const_dep)
+{
+	struct kbase_jd_atom_dependency* dep;
+
+	LOCAL_ASSERT(const_dep != NULL);
+
+	dep = (REINTERPRET_CAST(struct kbase_jd_atom_dependency* )const_dep);
+
+	dep->atom = NULL;
+	dep->dep_type = BASE_JD_DEP_TYPE_INVALID; 
+}
+
 struct kbase_ext_res
 {
 	mali_addr64 gpu_address;
@@ -232,7 +308,7 @@ struct kbase_jd_atom {
 
 	struct list_head dep_head[2];
 	struct list_head dep_item[2];
-	struct kbase_jd_atom *dep_atom[2];
+	const struct kbase_jd_atom_dependency dep[2];
 
 	u16 nr_extres;
 	struct kbase_ext_res * extres;
@@ -566,6 +642,7 @@ struct kbase_device {
 
 	struct list_head entry;
 	struct device *dev;
+	unsigned int kbase_group_error;
 	struct miscdevice mdev;
 	u64 reg_start;
 	size_t reg_size;
diff --git a/drivers/gpu/arm/midgard/mali_kbase_device.c b/drivers/gpu/arm/midgard/mali_kbase_device.c
index 6dfff10..1d69de4 100755
--- a/drivers/gpu/arm/midgard/mali_kbase_device.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_device.c
@@ -359,6 +359,7 @@ void kbase_report_gpu_fault(kbase_device *kbdev, int multiple)
 	address |= kbase_reg_read(kbdev, GPU_CONTROL_REG(GPU_FAULTADDRESS_LO), NULL);
 
 	dev_warn(kbdev->dev, "GPU Fault 0x%08x (%s) at 0x%016llx", status & 0xFF, kbase_exception_name(status), address);
+	kbdev->kbase_group_error++;
 	if (multiple)
 		dev_warn(kbdev->dev, "There were multiple GPU faults - some have not been reported\n");
 }
diff --git a/drivers/gpu/arm/midgard/mali_kbase_gpu_memory_debugfs.c b/drivers/gpu/arm/midgard/mali_kbase_gpu_memory_debugfs.c
index e2948b1..1338b6b 100755
--- a/drivers/gpu/arm/midgard/mali_kbase_gpu_memory_debugfs.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_gpu_memory_debugfs.c
@@ -48,10 +48,13 @@ static int kbasep_gpu_memory_seq_show(struct seq_file *sfile, void *data)
 		list_for_each_entry(element, &kbdev->kctx_list, link) {
 			/* output the memory usage and cap for each kctx
 			* opened on this device */
-			ret = seq_printf(sfile, "  %s-0x%p %10u\n", \
-				"kctx",
+			ret = seq_printf(sfile, "  %s-0x%p %10u %10u %10u %10u\n", \
+				"kctx", \
 				element->kctx, \
-				atomic_read(&(element->kctx->used_pages)));
+				element->kctx->pid, \
+				atomic_read(&(element->kctx->osalloc.free_list_size)), \
+				atomic_read(&(element->kctx->used_pages)), \
+				atomic_read(&(element->kctx->nonmapped_pages)));
 		}
 		mutex_unlock(&kbdev->kctx_list_lock);
 	}
diff --git a/drivers/gpu/arm/midgard/mali_kbase_jd.c b/drivers/gpu/arm/midgard/mali_kbase_jd.c
index 8d2c0ba..f5ddcf4 100755
--- a/drivers/gpu/arm/midgard/mali_kbase_jd.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_jd.c
@@ -151,7 +151,7 @@ static void kds_dep_clear(void *callback_parameter, void *callback_extra_paramet
 	katom->kds_dep_satisfied = MALI_TRUE;
 
 	/* Check whether the atom's other dependencies were already met */
-	if (!katom->dep_atom[0] && !katom->dep_atom[1]) {
+	if (!kbase_jd_katom_dep_atom(&katom->dep[0]) && !kbase_jd_katom_dep_atom(&katom->dep[1])) {
 		/* katom dep complete, attempt to run it */
 		mali_bool resched = MALI_FALSE;
 		resched = jd_run_atom(katom);
@@ -248,17 +248,16 @@ out:
 	return err;
 }
 
-static void kbase_jd_umm_unmap(kbase_context *kctx, struct kbase_va_region *reg, int mmu_update)
+static void kbase_jd_umm_unmap(kbase_context *kctx, struct kbase_mem_phy_alloc *alloc)
 {
 	KBASE_DEBUG_ASSERT(kctx);
-	KBASE_DEBUG_ASSERT(reg);
-	KBASE_DEBUG_ASSERT(reg->alloc->imported.umm.dma_attachment);
-	KBASE_DEBUG_ASSERT(reg->alloc->imported.umm.sgt);
-	if (mmu_update)
-		kbase_mmu_teardown_pages(kctx, reg->start_pfn, kbase_reg_current_backed_size(reg));
-	dma_buf_unmap_attachment(reg->alloc->imported.umm.dma_attachment, reg->alloc->imported.umm.sgt, DMA_BIDIRECTIONAL);
-	reg->alloc->imported.umm.sgt = NULL;
-	reg->alloc->nents = 0;
+	KBASE_DEBUG_ASSERT(alloc);
+	KBASE_DEBUG_ASSERT(alloc->imported.umm.dma_attachment);
+	KBASE_DEBUG_ASSERT(alloc->imported.umm.sgt);
+	dma_buf_unmap_attachment(alloc->imported.umm.dma_attachment,
+			alloc->imported.umm.sgt, DMA_BIDIRECTIONAL);
+	alloc->imported.umm.sgt = NULL;
+	alloc->nents = 0;
 }
 #endif				/* CONFIG_DMA_SHARED_BUFFER */
 
@@ -294,24 +293,29 @@ static void kbase_jd_post_external_resources(kbase_jd_atom *katom)
 		katom->kds_dep_satisfied = MALI_TRUE;
 #endif				/* CONFIG_KDS */
 
-#if defined(CONFIG_DMA_SHARED_BUFFER) || defined(CONFIG_MALI_DEBUG)
-	/* Lock also used in debug mode just for lock order checking */
 	kbase_gpu_vm_lock(katom->kctx);
-#endif				/* defined(CONFIG_DMA_SHARED_BUFFER) || defined(CONFIG_MALI_DEBUG) */
 	/* only roll back if extres is non-NULL */
 	if (katom->extres) {
 		u32 res_no;
 		res_no = katom->nr_extres;
 		while (res_no-- > 0) {
+			struct kbase_mem_phy_alloc *alloc = katom->extres[res_no].alloc;
 #ifdef CONFIG_DMA_SHARED_BUFFER
-			if (katom->extres[res_no].alloc->type == KBASE_MEM_TYPE_IMPORTED_UMM) {
-				kbase_va_region *reg;
-				int mmu_update = 0;
-				reg = kbase_region_tracker_find_region_base_address(katom->kctx, katom->extres[res_no].gpu_address);
-				if (reg && reg->alloc == katom->extres[res_no].alloc)
-					mmu_update = 1;
-				if (1 == katom->extres[res_no].alloc->imported.umm.current_mapping_usage_count--)
-					kbase_jd_umm_unmap(katom->kctx, reg, mmu_update);
+			if (alloc->type == KBASE_MEM_TYPE_IMPORTED_UMM) {
+				alloc->imported.umm.current_mapping_usage_count--;
+
+				if (0 == alloc->imported.umm.current_mapping_usage_count) {
+					struct kbase_va_region *reg;
+					reg = kbase_region_tracker_find_region_base_address(
+					          katom->kctx, katom->extres[res_no].gpu_address);
+
+					if (reg && reg->alloc == alloc) {
+						kbase_mmu_teardown_pages(katom->kctx, reg->start_pfn,
+						    kbase_reg_current_backed_size(reg));
+					}
+
+					kbase_jd_umm_unmap(katom->kctx, alloc);
+				}
 			}
 #endif	/* CONFIG_DMA_SHARED_BUFFER */
 			kbase_mem_phy_alloc_put(katom->extres[res_no].alloc);
@@ -319,10 +323,7 @@ static void kbase_jd_post_external_resources(kbase_jd_atom *katom)
 		kfree(katom->extres);
 		katom->extres = NULL;
 	}
-#if defined(CONFIG_DMA_SHARED_BUFFER) || defined(CONFIG_MALI_DEBUG)
-	/* Lock also used in debug mode just for lock order checking */
 	kbase_gpu_vm_unlock(katom->kctx);
-#endif				/* defined(CONFIG_DMA_SHARED_BUFFER) || defined(CONFIG_MALI_DEBUG) */
 }
 
 #if (defined(CONFIG_KDS) && defined(CONFIG_UMP)) || defined(CONFIG_DMA_SHARED_BUFFER_USES_KDS)
@@ -402,12 +403,8 @@ static mali_error kbase_jd_pre_external_resources(kbase_jd_atom *katom, const ba
 	}
 #endif				/* CONFIG_KDS */
 
-#if defined(CONFIG_DMA_SHARED_BUFFER) || defined(CONFIG_MALI_DEBUG)
 	/* need to keep the GPU VM locked while we set up UMM buffers */
-	/* Lock also used in debug mode just for lock order checking */
 	kbase_gpu_vm_lock(katom->kctx);
-#endif				/* defined(CONFIG_DMA_SHARED_BUFFER) || defined(CONFIG_MALI_DEBUG) */
-
 	for (res_no = 0; res_no < katom->nr_extres; res_no++) {
 		base_external_resource *res;
 		kbase_va_region *reg;
@@ -472,11 +469,8 @@ static mali_error kbase_jd_pre_external_resources(kbase_jd_atom *katom, const ba
 		katom->extres[res_no].alloc = kbase_mem_phy_alloc_get(reg->alloc);
 	}
 	/* successfully parsed the extres array */
-#if defined(CONFIG_DMA_SHARED_BUFFER) || defined(CONFIG_MALI_DEBUG)
 	/* drop the vm lock before we call into kds */
-	/* Lock also used in debug mode just for lock order checking */
 	kbase_gpu_vm_unlock(katom->kctx);
-#endif				/* defined(CONFIG_DMA_SHARED_BUFFER) || defined(CONFIG_MALI_DEBUG) */
 
 #ifdef CONFIG_KDS
 	if (kds_res_count) {
@@ -512,34 +506,35 @@ static mali_error kbase_jd_pre_external_resources(kbase_jd_atom *katom, const ba
 #ifdef CONFIG_KDS
  failed_kds_setup:
 
-#if defined(CONFIG_DMA_SHARED_BUFFER) || defined(CONFIG_MALI_DEBUG)
 	/* lock before we unmap */
-	/* Lock also used in debug mode just for lock order checking */
 	kbase_gpu_vm_lock(katom->kctx);
-#endif				/* defined(CONFIG_DMA_SHARED_BUFFER) || defined(CONFIG_MALI_DEBUG) */
 #endif				/* CONFIG_KDS */
 
  failed_loop:
 	/* undo the loop work */
 	while (res_no-- > 0) {
+		struct kbase_mem_phy_alloc *alloc = katom->extres[res_no].alloc;
 #ifdef CONFIG_DMA_SHARED_BUFFER
-		if (katom->extres[res_no].alloc->type == KBASE_MEM_TYPE_IMPORTED_UMM) {
-			struct kbase_va_region * reg;
-			int mmu_update = 0;
-			reg = kbase_region_tracker_find_region_base_address(katom->kctx, katom->extres[res_no].gpu_address);
-			if (reg && reg->alloc == katom->extres[res_no].alloc && reg->alloc->type)
-				mmu_update = 1;
-			katom->extres[res_no].alloc->imported.umm.current_mapping_usage_count--;
-			if (0 == reg->alloc->imported.umm.current_mapping_usage_count)
-				kbase_jd_umm_unmap(katom->kctx, reg, mmu_update);
+		if (alloc->type == KBASE_MEM_TYPE_IMPORTED_UMM) {
+			alloc->imported.umm.current_mapping_usage_count--;
+
+			if (0 == alloc->imported.umm.current_mapping_usage_count) {
+				struct kbase_va_region *reg;
+				reg = kbase_region_tracker_find_region_base_address(
+				          katom->kctx, katom->extres[res_no].gpu_address);
+
+				if (reg && reg->alloc == alloc) {
+					kbase_mmu_teardown_pages(katom->kctx, reg->start_pfn,
+					    kbase_reg_current_backed_size(reg));
+				}
+
+				kbase_jd_umm_unmap(katom->kctx, alloc);
+			}
 		}
 #endif				/* CONFIG_DMA_SHARED_BUFFER */
-		kbase_mem_phy_alloc_put(katom->extres[res_no].alloc);
+		kbase_mem_phy_alloc_put(alloc);
 	}
-#if defined(CONFIG_DMA_SHARED_BUFFER) || defined(CONFIG_MALI_DEBUG)
-	/* Lock also used in debug mode just for lock order checking */
 	kbase_gpu_vm_unlock(katom->kctx);
-#endif				/* defined(CONFIG_DMA_SHARED_BUFFER) || defined(CONFIG_MALI_DEBUG) */
 
  early_err_out:
 	kfree(katom->extres);
@@ -559,12 +554,13 @@ STATIC INLINE void jd_resolve_dep(struct list_head *out_list, kbase_jd_atom *kat
 		kbase_jd_atom *dep_atom = list_entry(katom->dep_head[d].next, kbase_jd_atom, dep_item[d]);
 		list_del(katom->dep_head[d].next);
 
-		dep_atom->dep_atom[d] = NULL;
+		kbase_jd_katom_dep_clear(&dep_atom->dep[d]);
+		
 		if (katom->event_code != BASE_JD_EVENT_DONE) {
 			/* Atom failed, so remove the other dependencies and immediately fail the atom */
-			if (dep_atom->dep_atom[other_d]) {
+			if (kbase_jd_katom_dep_atom(&dep_atom->dep[other_d])) {
 				list_del(&dep_atom->dep_item[other_d]);
-				dep_atom->dep_atom[other_d] = NULL;
+				kbase_jd_katom_dep_clear(&dep_atom->dep[other_d]);
 			}
 #ifdef CONFIG_KDS
 			if (!dep_atom->kds_dep_satisfied) {
@@ -575,12 +571,17 @@ STATIC INLINE void jd_resolve_dep(struct list_head *out_list, kbase_jd_atom *kat
 			}
 #endif
 
-			dep_atom->event_code = katom->event_code;
-			KBASE_DEBUG_ASSERT(dep_atom->status != KBASE_JD_ATOM_STATE_UNUSED);
-			dep_atom->status = KBASE_JD_ATOM_STATE_COMPLETED;
+			/* at this point a dependency to the failed job is already removed */
+			if ( !( kbase_jd_katom_dep_type(&dep_atom->dep[d]) == BASE_JD_DEP_TYPE_ORDER &&
+					katom->event_code > BASE_JD_EVENT_ACTIVE) )
+			{
+				dep_atom->event_code = katom->event_code;
+				KBASE_DEBUG_ASSERT(dep_atom->status != KBASE_JD_ATOM_STATE_UNUSED);
+				dep_atom->status = KBASE_JD_ATOM_STATE_COMPLETED;
+			}
 
 			list_add_tail(&dep_atom->dep_item[0], out_list);
-		} else if (!dep_atom->dep_atom[other_d]) {
+		} else if (!kbase_jd_katom_dep_atom(&dep_atom->dep[other_d])) {
 #ifdef CONFIG_KDS
 			if (dep_atom->kds_dep_satisfied)
 #endif
@@ -621,8 +622,8 @@ static void jd_check_force_failure(kbase_jd_atom *katom)
 	    (katom->core_req & BASEP_JD_REQ_EVENT_NEVER))
 		return;
 	for (i = 1; i < BASE_JD_ATOM_COUNT; i++) {
-		if (kctx->jctx.atoms[i].dep_atom[0] == katom ||
-		    kctx->jctx.atoms[i].dep_atom[1] == katom) {
+		if (kbase_jd_katom_dep_atom(&kctx->jctx.atoms[i].dep[0]) == katom ||
+		    kbase_jd_katom_dep_atom(&kctx->jctx.atoms[i].dep[1]) == katom) {
 			kbase_jd_atom *dep_atom = &kctx->jctx.atoms[i];
 
 			if ((dep_atom->core_req & BASEP_JD_REQ_ATOM_TYPE) ==
@@ -680,9 +681,9 @@ mali_bool jd_done_nolock(kbase_jd_atom *katom)
 	/* This is needed in case an atom is failed due to being invalid, this
 	 * can happen *before* the jobs that the atom depends on have completed */
 	for (i = 0; i < 2; i++) {
-		if (katom->dep_atom[i]) {
+		if ( kbase_jd_katom_dep_atom(&katom->dep[i])) {
 			list_del(&katom->dep_item[i]);
-			katom->dep_atom[i] = NULL;
+			kbase_jd_katom_dep_clear(&katom->dep[i]);
 		}
 	}
 
@@ -842,6 +843,8 @@ mali_bool jd_submit_atom(kbase_context *kctx,
 	katom->nice_prio = user_atom->prio;
 	katom->atom_flags = 0;
 	katom->retry_count = 0;
+
+	
 #ifdef CONFIG_KDS
 	/* Start by assuming that the KDS dependencies are satisfied,
 	 * kbase_jd_pre_external_resources will correct this if there are dependencies */
@@ -849,20 +852,52 @@ mali_bool jd_submit_atom(kbase_context *kctx,
 	katom->kds_rset = NULL;
 #endif				/* CONFIG_KDS */
 
+
+	/* Don't do anything if there is a mess up with dependencies.
+	   This is done in a separate cycle to check both the dependencies at ones, otherwise 
+	   it will be extra complexity to deal with 1st dependency ( just added to the list )
+	   if only the 2nd one has invalid config.
+	 */
+	for (i = 0; i < 2; i++) {
+		int dep_atom_number = user_atom->pre_dep[i].atom_id;
+		base_jd_dep_type dep_atom_type = user_atom->pre_dep[i].dependency_type;
+
+		if (dep_atom_number) {
+			if ( dep_atom_type != BASE_JD_DEP_TYPE_ORDER && dep_atom_type != BASE_JD_DEP_TYPE_DATA )
+			{
+				katom->event_code = BASE_JD_EVENT_JOB_CONFIG_FAULT;
+				katom->status = KBASE_JD_ATOM_STATE_COMPLETED;
+				ret = jd_done_nolock(katom);
+				goto out;
+			}
+		}
+	}
+	
 	/* Add dependencies */
 	for (i = 0; i < 2; i++) {
-		int dep_atom_number = user_atom->pre_dep[i];
-		katom->dep_atom[i] = NULL;
+		int dep_atom_number = user_atom->pre_dep[i].atom_id;
+		base_jd_dep_type dep_atom_type = user_atom->pre_dep[i].dependency_type;
+
+		kbase_jd_katom_dep_clear(&katom->dep[i]);
+
 		if (dep_atom_number) {
 			kbase_jd_atom *dep_atom = &jctx->atoms[dep_atom_number];
 
 			if (dep_atom->status == KBASE_JD_ATOM_STATE_UNUSED || dep_atom->status == KBASE_JD_ATOM_STATE_COMPLETED) {
 				if (dep_atom->event_code != BASE_JD_EVENT_DONE) {
-					if (i == 1 && katom->dep_atom[0]) {
+					/* don't stop this atom if it has an order dependency only to the failed one,
+					 try to submit it throught the normal path */
+					if ( dep_atom_type == BASE_JD_DEP_TYPE_ORDER &&
+							dep_atom->event_code > BASE_JD_EVENT_ACTIVE) {
+						continue;
+					}
+
+					if (i == 1 && kbase_jd_katom_dep_atom(&katom->dep[0])) {
 						/* Remove the previous dependency */
 						list_del(&katom->dep_item[0]);
-						katom->dep_atom[0] = NULL;
+						kbase_jd_katom_dep_clear(&katom->dep[0]);
 					}
+					
 					/* Atom has completed, propagate the error code if any */
 					katom->event_code = dep_atom->event_code;
 					katom->status = KBASE_JD_ATOM_STATE_QUEUED;
@@ -881,12 +916,13 @@ mali_bool jd_submit_atom(kbase_context *kctx,
 						}
 					}					
 					ret = jd_done_nolock(katom);
+					
 					goto out;
 				}
 			} else {
 				/* Atom is in progress, add this atom to the list */
 				list_add_tail(&katom->dep_item[i], &dep_atom->dep_head[i]);
-				katom->dep_atom[i] = dep_atom;
+				kbase_jd_katom_dep_set(&katom->dep[i], dep_atom, dep_atom_type);
 				queued = 1;
 			}
 		}
@@ -1449,7 +1485,9 @@ static enum hrtimer_restart zap_timeout_callback(struct hrtimer *timer)
 void kbase_jd_zap_context(kbase_context *kctx)
 {
 	kbase_jd_atom *katom;
-	struct list_head *entry;
+	#if 0
+	struct list_head *entry,*entry1;
+	#endif
 	kbase_device *kbdev;
 	zap_reset_data reset_data;
 	unsigned long flags;
@@ -1467,11 +1505,28 @@ void kbase_jd_zap_context(kbase_context *kctx)
 	 * While holding the kbase_jd_context lock clean up jobs which are known to kbase but are
 	 * queued outside the job scheduler.
 	 */
-
-	list_for_each( entry, &kctx->waiting_soft_jobs) {
+	
+	pr_info("%p,%p,%p\n",
+			&kctx->waiting_soft_jobs,
+			kctx->waiting_soft_jobs.next,
+			kctx->waiting_soft_jobs.prev);
+	
+	while (!list_empty(&kctx->waiting_soft_jobs)) {
+		katom = list_first_entry(&kctx->waiting_soft_jobs,
+								 struct kbase_jd_atom,
+								 dep_item[0]);
+		list_del(&katom->dep_item[0]);
+		kbase_cancel_soft_job(katom);
+	}
+	#if 0
+	list_for_each_safe(entry, entry1, &kctx->waiting_soft_jobs) {
+		if(entry == (struct list_head *)LIST_POISON1)
+			pr_err("@get to the end of a list, error happened in list somewhere@\n");
 		katom = list_entry(entry, kbase_jd_atom, dep_item[0]);
+			pr_info("katom = %p,&katom->dep_item[0] = %p\n",katom,&katom->dep_item[0]);
 		kbase_cancel_soft_job(katom);
 	}
+	#endif
 	/* kctx->waiting_soft_jobs is not valid after this point */
 
 #ifdef CONFIG_KDS
diff --git a/drivers/gpu/arm/midgard/mali_kbase_jm.c b/drivers/gpu/arm/midgard/mali_kbase_jm.c
index d3c6643..f276777 100755
--- a/drivers/gpu/arm/midgard/mali_kbase_jm.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_jm.c
@@ -357,6 +357,7 @@ void kbase_job_done(kbase_device *kbdev, u32 done)
 					/* fall throught */
 				default:
 					dev_warn(kbdev->dev, "error detected from slot %d, job status 0x%08x (%s)", i, completion_code, kbase_exception_name(completion_code));
+				kbdev->kbase_group_error++;
 				}
 			}
 
diff --git a/drivers/gpu/arm/midgard/mali_kbase_mem.c b/drivers/gpu/arm/midgard/mali_kbase_mem.c
index c913c14..f1f4476 100755
--- a/drivers/gpu/arm/midgard/mali_kbase_mem.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_mem.c
@@ -137,6 +137,8 @@ kbase_va_region *kbase_region_tracker_find_region_enclosing_address(kbase_contex
 
 	KBASE_DEBUG_ASSERT(NULL != kctx);
 
+	lockdep_assert_held(&kctx->reg_lock);
+
 	rbnode = kctx->reg_rbtree.rb_node;
 	while (rbnode) {
 		u64 tmp_start_pfn, tmp_end_pfn;
@@ -168,6 +170,8 @@ kbase_va_region *kbase_region_tracker_find_region_base_address(kbase_context *kc
 
 	KBASE_DEBUG_ASSERT(NULL != kctx);
 
+	lockdep_assert_held(&kctx->reg_lock);
+
 	rbnode = kctx->reg_rbtree.rb_node;
 	while (rbnode) {
 		reg = rb_entry(rbnode, struct kbase_va_region, rblink);
@@ -348,6 +352,8 @@ mali_error kbase_add_va_region(kbase_context *kctx, struct kbase_va_region *reg,
 	KBASE_DEBUG_ASSERT(NULL != kctx);
 	KBASE_DEBUG_ASSERT(NULL != reg);
 
+	lockdep_assert_held(&kctx->reg_lock);
+
 	if (!align)
 		align = 1;
 
diff --git a/drivers/gpu/arm/midgard/mali_kbase_mem.h b/drivers/gpu/arm/midgard/mali_kbase_mem.h
index 8cbde32..7baa6f8 100755
--- a/drivers/gpu/arm/midgard/mali_kbase_mem.h
+++ b/drivers/gpu/arm/midgard/mali_kbase_mem.h
@@ -278,15 +278,14 @@ static INLINE size_t kbase_reg_current_backed_size(struct kbase_va_region * reg)
 
 static INLINE struct kbase_mem_phy_alloc * kbase_alloc_create(size_t nr_pages, enum kbase_memory_type type)
 {
-	struct kbase_mem_phy_alloc * alloc;
-	const size_t extra_pages = (sizeof(*alloc) + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+	struct kbase_mem_phy_alloc *alloc;
 
 	/* Prevent nr_pages*sizeof + sizeof(*alloc) from wrapping around. */
-	if (nr_pages > (((size_t) -1 / sizeof(*alloc->pages))) - extra_pages)
+	if (nr_pages > ((((size_t) -1) - sizeof(*alloc)) / sizeof(*alloc->pages)))
 		return ERR_PTR(-ENOMEM);
 
 	alloc = vzalloc(sizeof(*alloc) + sizeof(*alloc->pages) * nr_pages);
-	if (!alloc) 
+	if (!alloc)
 		return ERR_PTR(-ENOMEM);
 
 	kref_init(&alloc->kref);
diff --git a/drivers/gpu/arm/midgard/mali_kbase_mem_linux.c b/drivers/gpu/arm/midgard/mali_kbase_mem_linux.c
index 59bafca..088fd55 100755
--- a/drivers/gpu/arm/midgard/mali_kbase_mem_linux.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_mem_linux.c
@@ -884,7 +884,7 @@ int kbase_mem_commit(kbase_context * kctx, mali_addr64 gpu_addr, u64 new_pages,
 						(first_bad << PAGE_SHIFT),
 						mapping->vm_end);
 				WARN(zap_res,
-				     "Failed to zap VA range (0x%lx -0x%lx);\n",
+				     "Failed to zap VA range (0x%lx - 0x%lx);\n",
 				     mapping->vm_start +
 				     (first_bad << PAGE_SHIFT),
 				     mapping->vm_end
@@ -1002,7 +1002,7 @@ static const struct vm_operations_struct kbase_vm_ops = {
 	.fault = kbase_cpu_vm_fault
 };
 
-static int kbase_cpu_mmap(struct kbase_va_region *reg, struct vm_area_struct *vma, void *kaddr, size_t nr_pages, int free_on_close)
+static int kbase_cpu_mmap(struct kbase_va_region *reg, struct vm_area_struct *vma, void *kaddr, size_t nr_pages, unsigned long aligned_offset, int free_on_close)
 {
 	struct kbase_cpu_mapping *map;
 	u64 start_off = vma->vm_pgoff - reg->start_pfn;
@@ -1077,8 +1077,13 @@ static int kbase_cpu_mmap(struct kbase_va_region *reg, struct vm_area_struct *vm
 	map->page_off = start_off;
 	map->region = free_on_close ? reg : NULL;
 	map->kctx = reg->kctx;
-	map->vm_start = vma->vm_start;
-	map->vm_end = vma->vm_end;
+	map->vm_start = vma->vm_start + aligned_offset;
+	if (aligned_offset) {
+		KBASE_DEBUG_ASSERT(!start_off);
+		map->vm_end = map->vm_start + (reg->nr_pages << PAGE_SHIFT);
+	} else {
+		map->vm_end = vma->vm_end;
+	}
 	map->alloc = kbase_mem_phy_alloc_get(reg->alloc);
 	map->count = 1; /* start with one ref */
 
@@ -1250,6 +1255,7 @@ int kbase_mmap(struct file *file, struct vm_area_struct *vma)
 	int err = 0;
 	int free_on_close = 0;
 	struct device *dev = kctx->kbdev->dev;
+	size_t aligned_offset = 0;
 
 	dev_dbg(dev, "kbase_mmap\n");
 	nr_pages = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;
@@ -1316,7 +1322,6 @@ int kbase_mmap(struct file *file, struct vm_area_struct *vma)
 		gpu_pc_bits = kctx->kbdev->gpu_props.props.core_props.log2_program_counter_size;
 		reg = kctx->pending_regions[cookie];
 		if (NULL != reg) {
-			size_t aligned_offset = 0;
 
 			if (reg->flags & KBASE_REG_ALIGNED) {
 				/* nr_pages must be able to hold alignment pages
@@ -1431,7 +1436,7 @@ overflow:
 	} /* default */
 	} /* switch */
 map:
-	err = kbase_cpu_mmap(reg, vma, kaddr, nr_pages, free_on_close);
+	err = kbase_cpu_mmap(reg, vma, kaddr, nr_pages, aligned_offset, free_on_close);
 
 	if (vma->vm_pgoff == PFN_DOWN(BASE_MEM_MMU_DUMP_HANDLE)) {
 		/* MMU dump - userspace should now have a reference on
diff --git a/drivers/gpu/arm/midgard/mali_kbase_mmu.c b/drivers/gpu/arm/midgard/mali_kbase_mmu.c
index 27fd4f2..5bfc8a2 100755
--- a/drivers/gpu/arm/midgard/mali_kbase_mmu.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_mmu.c
@@ -213,8 +213,8 @@ static void page_fault_worker(struct work_struct *data)
 		if (MALI_ERROR_NONE != err) {
 			/* failed to insert pages, handle as a normal PF */
 			mutex_unlock(&faulting_as->transaction_mutex);
-			kbase_gpu_vm_unlock(kctx);
 			kbase_free_phy_pages_helper(region->alloc, new_pages);
+			kbase_gpu_vm_unlock(kctx);
 			/* The locked VA region will be unlocked and the cache invalidated in here */
 			kbase_mmu_report_fault_and_kill(kctx, faulting_as);
 			goto fault_done;
@@ -1308,7 +1308,7 @@ void kbase_mmu_interrupt(kbase_device *kbdev, u32 irq_stat)
 
 		/* remove the queued PFs from the mask */
 		new_mask &= ~((1UL << as_no) | (1UL << (as_no + num_as)));
-
+		kbdev->kbase_group_error++;
 		/* queue work pending for this AS */
 		KBASE_DEBUG_ASSERT(0 == object_is_on_stack(&as->work_pagefault));
 		INIT_WORK(&as->work_pagefault, page_fault_worker);
diff --git a/drivers/gpu/arm/midgard/mali_kbase_pm.c b/drivers/gpu/arm/midgard/mali_kbase_pm.c
index a0cd00b..3fc6710 100755
--- a/drivers/gpu/arm/midgard/mali_kbase_pm.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_pm.c
@@ -401,13 +401,6 @@ void kbase_pm_suspend(struct kbase_device *kbdev)
 	 * reaches zero. */
 	wait_event(kbdev->pm.zero_active_count_wait, kbdev->pm.active_count == 0);
 
-	/* Suspend PM Metric timer on system suspend.
-	 * It is ok if kbase_pm_context_idle() is still running, it is safe
-	 * to still complete the last active time period - the pm stats will
-	 * get reset on resume anyway.
-	 */
-	kbasep_pm_metrics_term(kbdev);
-
 	/* NOTE: We synchronize with anything that was just finishing a
 	 * kbase_pm_context_idle() call by locking the pm.lock below */
 
@@ -427,14 +420,8 @@ void kbase_pm_resume(struct kbase_device *kbdev)
 	/* MUST happen before any pm_context_active calls occur */
 	mutex_lock(&kbdev->pm.lock);
 	kbdev->pm.suspending = MALI_FALSE;
-
 	kbase_pm_do_poweron(kbdev, MALI_TRUE);
-
 	mutex_unlock(&kbdev->pm.lock);
-	
-	/* Restart PM Metric timer on resume */
-	kbasep_pm_metrics_init(kbdev);
-	kbasep_pm_record_gpu_idle(kbdev);
 
 	/* Initial active call, to power on the GPU/cores if needed */
 	kbase_pm_context_active(kbdev);
diff --git a/drivers/gpu/arm/midgard/mali_kbase_pm_driver.c b/drivers/gpu/arm/midgard/mali_kbase_pm_driver.c
index eb752e0..85cb82d 100755
--- a/drivers/gpu/arm/midgard/mali_kbase_pm_driver.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_pm_driver.c
@@ -651,8 +651,12 @@ void kbase_pm_clock_on(kbase_device *kbdev, mali_bool is_resume)
 	if (is_resume && kbdev->pm.callback_power_resume) {
 		kbdev->pm.callback_power_resume(kbdev);
 	} else if (kbdev->pm.callback_power_on) {
-		if (kbdev->pm.callback_power_on(kbdev))
-			reset_required = MALI_TRUE;
+		kbdev->pm.callback_power_on(kbdev);
+		/* If your platform properly keeps the GPU state you may use the return
+		 * value of the callback_power_on function to conditionally reset the
+		 * GPU on power up. Currently we are conservative and always reset the
+		 * GPU. */
+		reset_required = MALI_TRUE;
 	}
 
 	spin_lock_irqsave(&kbdev->pm.gpu_powered_lock, flags);
@@ -750,8 +754,11 @@ static void kbase_pm_hw_issues(kbase_device *kbdev)
 	u32 value = 0;
 	u32 config_value;
 
-	/* Needed due to MIDBASE-1494: LS_PAUSEBUFFER_DISABLE. See PRLAM-8443. */
-	if (kbase_hw_has_issue(kbdev, BASE_HW_ISSUE_8443))
+	/* Needed due to MIDBASE-1494: LS_PAUSEBUFFER_DISABLE. See PRLAM-8443.
+	 * and
+	 * needed due to MIDGLES-3539. See PRLAM-11035 */
+	if (kbase_hw_has_issue(kbdev, BASE_HW_ISSUE_8443) ||
+			kbase_hw_has_issue(kbdev, BASE_HW_ISSUE_11035))
 		value |= SC_LS_PAUSEBUFFER_DISABLE;
 
 	/* Needed due to MIDBASE-2054: SDC_DISABLE_OQ_DISCARD. See PRLAM-10327. */
@@ -769,6 +776,11 @@ static void kbase_pm_hw_issues(kbase_device *kbdev)
 	if (value != 0)
 		kbase_reg_write(kbdev, GPU_CONTROL_REG(SHADER_CONFIG), value, NULL);
 
+	/* Set tiler clock gate override */
+	value = kbase_reg_read(kbdev, GPU_CONTROL_REG(TILER_CONFIG), NULL);
+	value |= (1u << 0);
+	kbase_reg_write(kbdev, GPU_CONTROL_REG(TILER_CONFIG), value, NULL);
+
 	/* Limit the GPU bus bandwidth if the platform needs this. */
 	value = kbase_reg_read(kbdev, GPU_CONTROL_REG(L2_MMU_CONFIG), NULL);
 
diff --git a/drivers/gpu/arm/midgard/mali_kbase_pm_policy.c b/drivers/gpu/arm/midgard/mali_kbase_pm_policy.c
index 7ac2d86..7e43512 100755
--- a/drivers/gpu/arm/midgard/mali_kbase_pm_policy.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_pm_policy.c
@@ -375,17 +375,18 @@ void kbase_pm_update_cores_state_nolock(kbase_device *kbdev)
 	/* Are any cores being powered on? */
 	if (~kbdev->pm.desired_shader_state & desired_bitmap ||
 	    kbdev->pm.ca_in_transition != MALI_FALSE) {
+
+		/* Check if we are powering off any cores before updating shader state */
+		if (kbdev->pm.desired_shader_state & ~desired_bitmap) {
+			/* Start timer to power off cores */
+			kbdev->pm.shader_poweroff_pending |= (kbdev->pm.desired_shader_state & ~desired_bitmap);
+			kbdev->pm.shader_poweroff_pending_time = kbdev->pm.poweroff_shader_ticks;
+		}
+
 		kbdev->pm.desired_shader_state = desired_bitmap;
 
 		/* If any cores are being powered on, transition immediately */
 		cores_are_available = kbase_pm_check_transitions_nolock(kbdev);
-
-		/* Ensure timer does not power off wanted cores */
-		if (kbdev->pm.shader_poweroff_pending != 0) {
-			kbdev->pm.shader_poweroff_pending &= ~kbdev->pm.desired_shader_state;
-			if (kbdev->pm.shader_poweroff_pending == 0)
-				kbdev->pm.shader_poweroff_pending_time = 0;
-		}
 	} else if (kbdev->pm.desired_shader_state & ~desired_bitmap) {
 		/* Start timer to power off cores */
 		kbdev->pm.shader_poweroff_pending |= (kbdev->pm.desired_shader_state & ~desired_bitmap);
@@ -397,6 +398,13 @@ void kbase_pm_update_cores_state_nolock(kbase_device *kbdev)
 		hrtimer_cancel(&kbdev->pm.gpu_poweroff_timer);
 	}
 
+	/* Ensure timer does not power off wanted cores and make sure to power off unwanted cores */
+	if (kbdev->pm.shader_poweroff_pending != 0) {
+		kbdev->pm.shader_poweroff_pending &= ~(kbdev->pm.desired_shader_state & desired_bitmap);
+		if (kbdev->pm.shader_poweroff_pending == 0)
+			kbdev->pm.shader_poweroff_pending_time = 0;
+	}
+
 	/* Don't need 'cores_are_available', because we don't return anything */
 	CSTD_UNUSED(cores_are_available);
 }
diff --git a/drivers/gpu/arm/midgard/mali_kbase_replay.c b/drivers/gpu/arm/midgard/mali_kbase_replay.c
index 0e9ed62..1f4ac3c 100755
--- a/drivers/gpu/arm/midgard/mali_kbase_replay.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_replay.c
@@ -681,7 +681,7 @@ static void kbasep_replay_reset_softjob(kbase_jd_atom *katom,
 						       kbase_jd_atom *dep_atom)
 {
 	katom->status = KBASE_JD_ATOM_STATE_QUEUED;
-	katom->dep_atom[0] = dep_atom;
+	kbase_jd_katom_dep_set(&katom->dep[0],dep_atom, BASE_JD_DEP_TYPE_DATA);
 	list_add_tail(&katom->dep_item[0], &dep_atom->dep_head[0]);
 }
 
@@ -752,8 +752,8 @@ static void kbasep_replay_create_atom(kbase_context *kctx,
 	atom->prio = ((prio << 16) / ((20 << 16) / 128)) - 128;
 	atom->atom_number = atom_nr;
 
-	atom->pre_dep[0] = 0;
-	atom->pre_dep[1] = 0;
+	base_jd_atom_dep_set(&atom->pre_dep[0], 0 , BASE_JD_DEP_TYPE_INVALID);
+	base_jd_atom_dep_set(&atom->pre_dep[1], 0 , BASE_JD_DEP_TYPE_INVALID);
 
 	atom->udata.blob[0] = 0;
 	atom->udata.blob[1] = 0;
@@ -801,7 +801,7 @@ static mali_error kbasep_replay_create_atoms(kbase_context *kctx,
 	kbasep_replay_create_atom(kctx, t_atom, t_atom_nr, prio);
 	kbasep_replay_create_atom(kctx, f_atom, f_atom_nr, prio);
 
-	f_atom->pre_dep[0] = t_atom_nr;
+	base_jd_atom_dep_set(&f_atom->pre_dep[0], t_atom_nr , BASE_JD_DEP_TYPE_DATA);
 
 	return MALI_ERROR_NONE;
 }
diff --git a/drivers/gpu/arm/midgard/mali_kbase_softjobs.c b/drivers/gpu/arm/midgard/mali_kbase_softjobs.c
index 82ee7c4..0324f9d 100755
--- a/drivers/gpu/arm/midgard/mali_kbase_softjobs.c
+++ b/drivers/gpu/arm/midgard/mali_kbase_softjobs.c
@@ -39,7 +39,7 @@
 static int kbase_dump_cpu_gpu_time(kbase_jd_atom *katom)
 {
 	kbase_va_region *reg;
-	phys_addr_t addr;
+	phys_addr_t addr = 0;
 	u64 pfn;
 	u32 offset;
 	char *page;
@@ -111,19 +111,14 @@ static int kbase_dump_cpu_gpu_time(kbase_jd_atom *katom)
 		return 0;
 	}
 
+	kbase_gpu_vm_lock(kctx);
 	reg = kbase_region_tracker_find_region_enclosing_address(kctx, jc);
-	if (!reg)
-		return 0;
-
-	if (!(reg->flags & KBASE_REG_GPU_WR)) {
-		/* Region is not writable by GPU so we won't write to it either */
-		return 0;
-	}
-
-	if (!reg->alloc->pages)
-		return 0;
+	if (reg &&
+	    (reg->flags & KBASE_REG_GPU_WR) &&
+	    reg->alloc && reg->alloc->pages)
+		addr = reg->alloc->pages[pfn - reg->start_pfn];
 
-	addr = reg->alloc->pages[pfn - reg->start_pfn];
+	kbase_gpu_vm_unlock(kctx);
 	if (!addr)
 		return 0;
 
diff --git a/drivers/gpu/arm/midgard/mali_kbase_uku.h b/drivers/gpu/arm/midgard/mali_kbase_uku.h
index 84ab305..f1dd105 100755
--- a/drivers/gpu/arm/midgard/mali_kbase_uku.h
+++ b/drivers/gpu/arm/midgard/mali_kbase_uku.h
@@ -46,7 +46,7 @@
 
 #include "mali_kbase_gpuprops_types.h"
 
-#define BASE_UK_VERSION_MAJOR 6
+#define BASE_UK_VERSION_MAJOR 7
 #define BASE_UK_VERSION_MINOR 0
 
 typedef struct kbase_uk_mem_alloc {
@@ -300,9 +300,7 @@ typedef enum kbase_uk_function_id {
 	KBASE_FUNC_MEM_FLAGS_CHANGE,
 	KBASE_FUNC_MEM_ALIAS,
 
-	KBASE_FUNC_JOB_SUBMIT,
-
-	KBASE_FUNC_SYNC,
+	KBASE_FUNC_SYNC  = (UK_FUNC_ID + 8),
 
 	KBASE_FUNC_POST_TERM,
 
@@ -328,9 +326,12 @@ typedef enum kbase_uk_function_id {
 	KBASE_FUNC_FENCE_VALIDATE,
 	KBASE_FUNC_STREAM_CREATE,
 	KBASE_FUNC_GET_PROFILING_CONTROLS,
-	KBASE_FUNC_SET_PROFILING_CONTROLS /* to be used only for testing
+	KBASE_FUNC_SET_PROFILING_CONTROLS, /* to be used only for testing
 					   * purposes, otherwise these controls
 					   * are set through gator API */
+	KBASE_FUNC_JOB_SUBMIT = (UK_FUNC_ID + 27)
+
 } kbase_uk_function_id;
 
+
 #endif				/* _KBASE_UKU_H_ */
diff --git a/drivers/gpu/arm/midgard/mali_midg_regmap.h b/drivers/gpu/arm/midgard/mali_midg_regmap.h
index d3848ad..375da1e 100755
--- a/drivers/gpu/arm/midgard/mali_midg_regmap.h
+++ b/drivers/gpu/arm/midgard/mali_midg_regmap.h
@@ -185,6 +185,7 @@
 #define L3_PWRACTIVE_HI         0x274	/* (RO) Level 3 cache active bitmap, high word */
 
 #define SHADER_CONFIG           0xF04	/* (RW) Shader core configuration settings (Mali-T60x additional register) */
+#define TILER_CONFIG            0xF08
 #define L2_MMU_CONFIG           0xF0C	/* (RW) Configuration of the L2 cache and MMU (Mali-T60x additional register) */
 
 #define JOB_CONTROL_BASE        0x1000
diff --git a/drivers/gpu/arm/midgard/platform/juno_soc/Kbuild b/drivers/gpu/arm/midgard/platform/juno_soc/Kbuild
new file mode 100755
index 0000000..f6af622
--- /dev/null
+++ b/drivers/gpu/arm/midgard/platform/juno_soc/Kbuild
@@ -0,0 +1,19 @@
+#
+# (C) COPYRIGHT 2013 ARM Limited. All rights reserved.
+#
+# This program is free software and is provided to you under the terms of the
+# GNU General Public License version 2 as published by the Free Software
+# Foundation, and any use by you of this program is subject to the terms
+# of such GNU licence.
+#
+# A copy of the licence is included with the program, and can also be obtained
+# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+# Boston, MA  02110-1301, USA.
+#
+#
+
+
+obj-y += mali_kbase_config_juno_soc.o
+
+
+obj-m += juno_mali_opp.o
diff --git a/drivers/gpu/arm/midgard/platform/juno_soc/juno_mali_opp.c b/drivers/gpu/arm/midgard/platform/juno_soc/juno_mali_opp.c
new file mode 100755
index 0000000..bd3d1c4
--- /dev/null
+++ b/drivers/gpu/arm/midgard/platform/juno_soc/juno_mali_opp.c
@@ -0,0 +1,73 @@
+/*
+ *
+ * (C) COPYRIGHT ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/pm_opp.h>
+#include <linux/scpi_protocol.h>
+
+
+static int init_juno_opps_from_scpi(struct device *dev)
+{
+	struct scpi_opp *sopp;
+	int i;
+
+	/* Hard coded for Juno. 2 is GPU domain */
+	sopp = scpi_dvfs_get_opps(2);
+	if (IS_ERR_OR_NULL(sopp))
+		return PTR_ERR(sopp);
+
+	for (i = 0; i < sopp->count; i++) {
+		struct scpi_opp_entry *e = &sopp->opp[i];
+		dev_info(dev, "Mali OPP from SCPI: %u Hz @ %u mV\n",
+				e->freq_hz, e->volt_mv);
+
+		dev_pm_opp_add(dev, e->freq_hz, e->volt_mv * 1000);
+	}
+
+	return 0;
+}
+
+static int juno_setup_opps(void)
+{
+	struct device_node *np;
+	struct platform_device *pdev;
+	int err;
+
+	np = of_find_node_by_name(NULL, "gpu");
+	if (!np) {
+		printk(KERN_ERR "Failed to find DT entry for Mali\n");
+		return -EFAULT;
+	}
+
+	pdev = of_find_device_by_node(np);
+	if (!pdev) {
+		printk(KERN_ERR "Failed to find device for Mali\n");
+		of_node_put(np);
+		return -EFAULT;
+	}
+
+	err = init_juno_opps_from_scpi(&pdev->dev);
+
+	of_node_put(np);
+
+	return err;
+}
+
+module_init(juno_setup_opps);
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/arm/midgard/platform/juno_soc/mali_kbase_config_juno_soc.c b/drivers/gpu/arm/midgard/platform/juno_soc/mali_kbase_config_juno_soc.c
new file mode 100755
index 0000000..d8f1433
--- /dev/null
+++ b/drivers/gpu/arm/midgard/platform/juno_soc/mali_kbase_config_juno_soc.c
@@ -0,0 +1,134 @@
+/*
+ *
+ * (C) COPYRIGHT ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+#include <linux/ioport.h>
+#include <mali_kbase.h>
+#include <mali_kbase_defs.h>
+#include <mali_kbase_config.h>
+
+#include "../mali_kbase_power_actor.h"
+
+/* Versatile Express (VE) Juno Development Platform */
+
+#define HARD_RESET_AT_POWER_OFF 0
+
+#ifndef CONFIG_OF
+static struct kbase_io_resources io_resources = {
+	.job_irq_number = 65,
+	.mmu_irq_number = 66,
+	.gpu_irq_number = 64,
+	.io_memory_region = {
+			     .start = 0x2D000000,
+			     .end = 0x2D000000 + (4096 * 4) - 1}
+};
+#endif
+
+static int pm_callback_power_on(struct kbase_device *kbdev)
+{
+	/* Nothing is needed on VExpress, but we may have destroyed GPU state (if the below HARD_RESET code is active) */
+	return 1;
+}
+
+static void pm_callback_power_off(struct kbase_device *kbdev)
+{
+#if HARD_RESET_AT_POWER_OFF
+	/* Cause a GPU hard reset to test whether we have actually idled the GPU
+	 * and that we properly reconfigure the GPU on power up.
+	 * Usually this would be dangerous, but if the GPU is working correctly it should
+	 * be completely safe as the GPU should not be active at this point.
+	 * However this is disabled normally because it will most likely interfere with
+	 * bus logging etc.
+	 */
+	KBASE_TRACE_ADD(kbdev, CORE_GPU_HARD_RESET, NULL, NULL, 0u, 0);
+	kbase_os_reg_write(kbdev, GPU_CONTROL_REG(GPU_COMMAND), GPU_COMMAND_HARD_RESET);
+#endif
+}
+
+static struct kbase_pm_callback_conf pm_callbacks = {
+	.power_on_callback = pm_callback_power_on,
+	.power_off_callback = pm_callback_power_off,
+	.power_suspend_callback  = NULL,
+	.power_resume_callback = NULL
+};
+
+static unsigned long juno_model_static_power(unsigned long voltage, unsigned long temperature)
+{
+	/* Calculate power, corrected for voltage.
+	 * Shifts are done to avoid overflow. */
+	const unsigned long coefficient = (410UL << 20) / (729000000UL >> 10);
+	const unsigned long voltage_cubed = (voltage * voltage * voltage) >> 10;
+
+	/* Calculate the temperature scaling factor. To be applied to the
+	 * voltage scaled power. */
+	const unsigned long temp = temperature / 1000;
+	const unsigned long temp_squared = temp * temp;
+	const unsigned long temp_cubed = temp_squared * temp;
+	const unsigned long temp_scaling_factor =
+			(2 * temp_cubed)
+			- (80 * temp_squared)
+			+ (4700 * temp)
+			+ 32000;
+
+	return (((coefficient * voltage_cubed) >> 20) * temp_scaling_factor) / 1000000;
+}
+
+static unsigned long juno_model_dynamic_power(unsigned long freq,
+		unsigned long voltage)
+{
+	/* The inputs: freq (f) is in Hz, and voltage (v) in mV.
+	 * The coefficient (c) is in mW/(MHz mV mV).
+	 *
+	 * This function calculates the dynamic power after this formula:
+	 * Pdyn (mW) = c (mW/(MHz*mV*mV)) * v (mV) * v (mV) * f (MHz)
+	 */
+	const unsigned long v2 = (voltage * voltage) / 1000; /* m*(V*V) */
+	const unsigned long f_mhz = freq / 1000000; /* MHz */
+	const unsigned long coefficient = 3600; /* mW/(MHz*mV*mV) */
+
+	return (coefficient * v2 * f_mhz) / 1000000; /* mW */
+}
+
+static struct mali_pa_model_ops juno_model_ops = {
+	.get_static_power = juno_model_static_power,
+	.get_dynamic_power = juno_model_dynamic_power,
+};
+
+static struct kbase_attribute config_attributes[] = {
+	{ KBASE_CONFIG_ATTR_JS_RESET_TIMEOUT_MS, 500 },
+	{ KBASE_CONFIG_ATTR_POWER_MANAGEMENT_CALLBACKS, ((uintptr_t)&pm_callbacks) },
+	{ KBASE_CONFIG_ATTR_POWER_MODEL_CALLBACKS, ((uintptr_t)&juno_model_ops) },
+
+	{ KBASE_CONFIG_ATTR_END, 0 }
+};
+
+static struct kbase_platform_config versatile_platform_config = {
+	.attributes = config_attributes,
+#ifndef CONFIG_OF
+	.io_resources = &io_resources
+#endif
+};
+
+struct kbase_platform_config *kbase_get_platform_config(void)
+{
+	return &versatile_platform_config;
+}
+
+int kbase_platform_early_init(void)
+{
+	/* Nothing needed at this stage */
+	return 0;
+}
diff --git a/drivers/gpu/arm/midgard/platform/juno_soc/mali_kbase_config_platform.h b/drivers/gpu/arm/midgard/platform/juno_soc/mali_kbase_config_platform.h
new file mode 100755
index 0000000..196de71
--- /dev/null
+++ b/drivers/gpu/arm/midgard/platform/juno_soc/mali_kbase_config_platform.h
@@ -0,0 +1,33 @@
+/*
+ *
+ * (C) COPYRIGHT ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+/**
+ * Maximum frequency GPU will be clocked at. Given in kHz.
+ * This must be specified as there is no default value.
+ *
+ * Attached value: number in kHz
+ * Default value: NA
+ */
+#define GPU_FREQ_KHZ_MAX 600000
+/**
+ * Minimum frequency GPU will be clocked at. Given in kHz.
+ * This must be specified as there is no default value.
+ *
+ * Attached value: number in kHz
+ * Default value: NA
+ */
+#define GPU_FREQ_KHZ_MIN 600000
diff --git a/drivers/gpu/arm/midgard/platform/vexpress_1xv7_a57/Kbuild b/drivers/gpu/arm/midgard/platform/vexpress_1xv7_a57/Kbuild
new file mode 100755
index 0000000..d9bfabc
--- /dev/null
+++ b/drivers/gpu/arm/midgard/platform/vexpress_1xv7_a57/Kbuild
@@ -0,0 +1,16 @@
+#
+# (C) COPYRIGHT 2013 ARM Limited. All rights reserved.
+#
+# This program is free software and is provided to you under the terms of the
+# GNU General Public License version 2 as published by the Free Software
+# Foundation, and any use by you of this program is subject to the terms
+# of such GNU licence.
+#
+# A copy of the licence is included with the program, and can also be obtained
+# from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+# Boston, MA  02110-1301, USA.
+#
+#
+
+
+obj-y += mali_kbase_config_vexpress.o
diff --git a/drivers/gpu/arm/midgard/platform/vexpress_1xv7_a57/mali_kbase_config_platform.h b/drivers/gpu/arm/midgard/platform/vexpress_1xv7_a57/mali_kbase_config_platform.h
new file mode 100755
index 0000000..8125948
--- /dev/null
+++ b/drivers/gpu/arm/midgard/platform/vexpress_1xv7_a57/mali_kbase_config_platform.h
@@ -0,0 +1,33 @@
+/*
+ *
+ * (C) COPYRIGHT ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+/**
+ * Maximum frequency GPU will be clocked at. Given in kHz.
+ * This must be specified as there is no default value.
+ *
+ * Attached value: number in kHz
+ * Default value: NA
+ */
+#define GPU_FREQ_KHZ_MAX 5000
+/**
+ * Minimum frequency GPU will be clocked at. Given in kHz.
+ * This must be specified as there is no default value.
+ *
+ * Attached value: number in kHz
+ * Default value: NA
+ */
+#define GPU_FREQ_KHZ_MIN 5000
diff --git a/drivers/gpu/arm/midgard/platform/vexpress_1xv7_a57/mali_kbase_config_vexpress.c b/drivers/gpu/arm/midgard/platform/vexpress_1xv7_a57/mali_kbase_config_vexpress.c
new file mode 100755
index 0000000..0ec2821
--- /dev/null
+++ b/drivers/gpu/arm/midgard/platform/vexpress_1xv7_a57/mali_kbase_config_vexpress.c
@@ -0,0 +1,279 @@
+/*
+ *
+ * (C) COPYRIGHT ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the
+ * GNU General Public License version 2 as published by the Free Software
+ * Foundation, and any use by you of this program is subject to the terms
+ * of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained
+ * from Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301, USA.
+ *
+ */
+
+
+
+#include <linux/ioport.h>
+#include <mali_kbase.h>
+#include <mali_kbase_defs.h>
+#include <mali_kbase_config.h>
+
+/* Versatile Express (VE) configuration defaults shared between config_attributes[]
+ * and config_attributes_hw_issue_8408[]. Settings are not shared for
+ * JS_HARD_STOP_TICKS_SS and JS_RESET_TICKS_SS.
+ */
+#define KBASE_VE_JS_SCHEDULING_TICK_NS_DEBUG    3000000000u	/* 3s */
+#define KBASE_VE_JS_SOFT_STOP_TICKS_DEBUG       10	/* 30s */
+#define KBASE_VE_JS_SOFT_STOP_TICKS_CL_DEBUG     5	/* 15s */
+#define KBASE_VE_JS_HARD_STOP_TICKS_SS_DEBUG    20	/* 60s */
+#define KBASE_VE_JS_HARD_STOP_TICKS_SS_8401_DEBUG 120	/* 360s */
+#define KBASE_VE_JS_HARD_STOP_TICKS_CL_DEBUG    10	/* 30s */
+#define KBASE_VE_JS_HARD_STOP_TICKS_NSS_DEBUG   6000	/* 18000s */
+#define KBASE_VE_JS_RESET_TICKS_SS_DEBUG        30	/* 180s */
+#define KBASE_VE_JS_RESET_TICKS_SS_8401_DEBUG   180	/* 540s */
+#define KBASE_VE_JS_RESET_TICKS_CL_DEBUG        30	/* 180s */
+#define KBASE_VE_JS_RESET_TICKS_NSS_DEBUG       6010	/* 18030s*/
+
+#define KBASE_VE_JS_SCHEDULING_TICK_NS          3000000000u	/* 3s */
+#define KBASE_VE_JS_SOFT_STOP_TICKS             10	/* 30s */
+#define KBASE_VE_JS_SOFT_STOP_TICKS_CL           5	/* 15s */
+#define KBASE_VE_JS_HARD_STOP_TICKS_SS          20	/* 60s */
+#define KBASE_VE_JS_HARD_STOP_TICKS_SS_8401     120	/* 360s */
+#define KBASE_VE_JS_HARD_STOP_TICKS_CL          10	/* 30s */
+#define KBASE_VE_JS_HARD_STOP_TICKS_NSS         6000	/* 18000s */
+#define KBASE_VE_JS_RESET_TICKS_SS              30	/* 180s */
+#define KBASE_VE_JS_RESET_TICKS_SS_8401         180	/* 540s */
+#define KBASE_VE_JS_RESET_TICKS_CL              30	/* 180s */
+#define KBASE_VE_JS_RESET_TICKS_NSS             6010	/* 18030s*/
+
+#define KBASE_VE_JS_RESET_TIMEOUT_MS            3000	/* 3s before cancelling stuck jobs */
+#define KBASE_VE_JS_CTX_TIMESLICE_NS            1000000	/* 1ms - an agressive timeslice for testing purposes (causes lots of scheduling out for >4 ctxs) */
+#define KBASE_VE_POWER_MANAGEMENT_CALLBACKS     ((uintptr_t)&pm_callbacks)
+
+#define HARD_RESET_AT_POWER_OFF 0
+
+#ifndef CONFIG_OF
+static struct kbase_io_resources io_resources = {
+	.job_irq_number = 68,
+	.mmu_irq_number = 69,
+	.gpu_irq_number = 70,
+	.io_memory_region = {
+			     .start = 0x2f010000,
+			     .end = 0x2f010000 + (4096 * 4) - 1}
+};
+#endif
+
+static int pm_callback_power_on(struct kbase_device *kbdev)
+{
+	/* Nothing is needed on VExpress, but we may have destroyed GPU state (if the below HARD_RESET code is active) */
+	return 1;
+}
+
+static void pm_callback_power_off(struct kbase_device *kbdev)
+{
+#if HARD_RESET_AT_POWER_OFF
+	/* Cause a GPU hard reset to test whether we have actually idled the GPU
+	 * and that we properly reconfigure the GPU on power up.
+	 * Usually this would be dangerous, but if the GPU is working correctly it should
+	 * be completely safe as the GPU should not be active at this point.
+	 * However this is disabled normally because it will most likely interfere with
+	 * bus logging etc.
+	 */
+	KBASE_TRACE_ADD(kbdev, CORE_GPU_HARD_RESET, NULL, NULL, 0u, 0);
+	kbase_os_reg_write(kbdev, GPU_CONTROL_REG(GPU_COMMAND), GPU_COMMAND_HARD_RESET);
+#endif
+}
+
+static struct kbase_pm_callback_conf pm_callbacks = {
+	.power_on_callback = pm_callback_power_on,
+	.power_off_callback = pm_callback_power_off,
+	.power_suspend_callback  = NULL,
+	.power_resume_callback = NULL
+};
+
+/* Please keep table config_attributes in sync with config_attributes_hw_issue_8408 */
+static struct kbase_attribute config_attributes[] = {
+#ifdef CONFIG_MALI_DEBUG
+/* Use more aggressive scheduling timeouts in debug builds for testing purposes */
+	{
+	 KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS,
+	 KBASE_VE_JS_SCHEDULING_TICK_NS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS,
+	 KBASE_VE_JS_SOFT_STOP_TICKS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS_CL,
+	 KBASE_VE_JS_SOFT_STOP_TICKS_CL_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_SS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_CL,
+	 KBASE_VE_JS_HARD_STOP_TICKS_CL_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_NSS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS,
+	 KBASE_VE_JS_RESET_TICKS_SS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_CL,
+	 KBASE_VE_JS_RESET_TICKS_CL_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS,
+	 KBASE_VE_JS_RESET_TICKS_NSS_DEBUG},
+#else				/* CONFIG_MALI_DEBUG */
+/* In release builds same as the defaults but scaled for 5MHz FPGA */
+	{
+	 KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS,
+	 KBASE_VE_JS_SCHEDULING_TICK_NS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS,
+	 KBASE_VE_JS_SOFT_STOP_TICKS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS_CL,
+	 KBASE_VE_JS_SOFT_STOP_TICKS_CL},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_SS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_CL,
+	 KBASE_VE_JS_HARD_STOP_TICKS_CL},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_NSS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS,
+	 KBASE_VE_JS_RESET_TICKS_SS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_CL,
+	 KBASE_VE_JS_RESET_TICKS_CL},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS,
+	 KBASE_VE_JS_RESET_TICKS_NSS},
+#endif				/* CONFIG_MALI_DEBUG */
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TIMEOUT_MS,
+	 KBASE_VE_JS_RESET_TIMEOUT_MS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_CTX_TIMESLICE_NS,
+	 KBASE_VE_JS_CTX_TIMESLICE_NS},
+
+	{
+	 KBASE_CONFIG_ATTR_POWER_MANAGEMENT_CALLBACKS,
+	 KBASE_VE_POWER_MANAGEMENT_CALLBACKS},
+
+	{
+	 KBASE_CONFIG_ATTR_END,
+	 0}
+};
+
+/* as config_attributes array above except with different settings for
+ * JS_HARD_STOP_TICKS_SS, JS_RESET_TICKS_SS that
+ * are needed for BASE_HW_ISSUE_8408.
+ */
+struct kbase_attribute config_attributes_hw_issue_8408[] = {
+#ifdef CONFIG_MALI_DEBUG
+/* Use more aggressive scheduling timeouts in debug builds for testing purposes */
+	{
+	 KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS,
+	 KBASE_VE_JS_SCHEDULING_TICK_NS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS,
+	 KBASE_VE_JS_SOFT_STOP_TICKS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_SS_8401_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_NSS_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS,
+	 KBASE_VE_JS_RESET_TICKS_SS_8401_DEBUG},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS,
+	 KBASE_VE_JS_RESET_TICKS_NSS_DEBUG},
+#else				/* CONFIG_MALI_DEBUG */
+/* In release builds same as the defaults but scaled for 5MHz FPGA */
+	{
+	 KBASE_CONFIG_ATTR_JS_SCHEDULING_TICK_NS,
+	 KBASE_VE_JS_SCHEDULING_TICK_NS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_SOFT_STOP_TICKS,
+	 KBASE_VE_JS_SOFT_STOP_TICKS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_SS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_SS_8401},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_HARD_STOP_TICKS_NSS,
+	 KBASE_VE_JS_HARD_STOP_TICKS_NSS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_SS,
+	 KBASE_VE_JS_RESET_TICKS_SS_8401},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TICKS_NSS,
+	 KBASE_VE_JS_RESET_TICKS_NSS},
+#endif				/* CONFIG_MALI_DEBUG */
+	{
+	 KBASE_CONFIG_ATTR_JS_RESET_TIMEOUT_MS,
+	 KBASE_VE_JS_RESET_TIMEOUT_MS},
+
+	{
+	 KBASE_CONFIG_ATTR_JS_CTX_TIMESLICE_NS,
+	 KBASE_VE_JS_CTX_TIMESLICE_NS},
+
+	{
+	 KBASE_CONFIG_ATTR_POWER_MANAGEMENT_CALLBACKS,
+	 KBASE_VE_POWER_MANAGEMENT_CALLBACKS},
+
+	{
+	 KBASE_CONFIG_ATTR_END,
+	 0}
+};
+
+static struct kbase_platform_config versatile_platform_config = {
+	.attributes = config_attributes,
+#ifndef CONFIG_OF
+	.io_resources = &io_resources
+#endif
+};
+
+struct kbase_platform_config *kbase_get_platform_config(void)
+{
+	return &versatile_platform_config;
+}
+
+int kbase_platform_early_init(void)
+{
+	/* Nothing needed at this stage */
+	return 0;
+}
-- 
1.7.9.5

